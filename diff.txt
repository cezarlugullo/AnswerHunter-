diff --git a/src/controllers/PopupController.js b/src/controllers/PopupController.js
index 51b587c..4a2671d 100644
--- a/src/controllers/PopupController.js
+++ b/src/controllers/PopupController.js
@@ -524,9 +524,14 @@ export const PopupController = {
 
     try {
       let ok = false;
+      let failReason = '';
       if (provider === 'groq') ok = await this.testGroqKey(key);
       if (provider === 'serper') ok = await this.testSerperKey(key);
-      if (provider === 'gemini') ok = await this.testGeminiKey(key);
+      if (provider === 'gemini') {
+        const geminiCheck = await this.testGeminiKey(key);
+        ok = !!geminiCheck?.ok;
+        failReason = geminiCheck?.reason || '';
+      }
 
       if (ok) {
         this.view.setTestButtonLoading(provider, 'ok');
@@ -548,8 +553,18 @@ export const PopupController = {
         }
       } else {
         this.view.setTestButtonLoading(provider, 'fail');
-        this.view.setSetupStatus(provider, this.t('setup.status.error'), 'fail');
-        this.view.showToast(this.t('setup.toast.invalidKey'), 'error');
+        if (provider === 'gemini' && failReason === 'quota') {
+          const quotaMsg = 'Chave valida, mas o projeto Gemini esta sem cota (HTTP 429). Trocar a chave no mesmo projeto nao resolve.';
+          this.view.setSetupStatus(provider, quotaMsg, 'fail');
+          this.view.showToast(quotaMsg, 'warning');
+        } else if (provider === 'gemini' && failReason === 'rate_limit') {
+          const rateMsg = 'Gemini respondeu 429 por limite de taxa. Tente novamente em alguns segundos.';
+          this.view.setSetupStatus(provider, rateMsg, 'fail');
+          this.view.showToast(rateMsg, 'warning');
+        } else {
+          this.view.setSetupStatus(provider, this.t('setup.status.error'), 'fail');
+          this.view.showToast(this.t('setup.toast.invalidKey'), 'error');
+        }
         input.classList.remove('input-valid');
       }
     } catch (error) {
@@ -608,10 +623,33 @@ export const PopupController = {
 
   async testGeminiKey(key) {
     try {
-      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
-      return response.ok;
+      const url = 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions';
+      const response = await fetch(url, {
+        method: 'POST',
+        headers: {
+          Authorization: `Bearer ${key}`,
+          'Content-Type': 'application/json'
+        },
+        body: JSON.stringify({
+          model: 'gemini-2.5-flash',
+          messages: [{ role: 'user', content: 'healthcheck' }],
+          max_tokens: 1,
+          temperature: 0
+        })
+      });
+
+      if (response.ok) return { ok: true };
+
+      const errText = await response.text().catch(() => '');
+      if (response.status === 429) {
+        if (/exceeded your current quota|plan and billing|quota/i.test(errText)) {
+          return { ok: false, reason: 'quota' };
+        }
+        return { ok: false, reason: 'rate_limit' };
+      }
+      return { ok: false, reason: `http_${response.status}` };
     } catch (_) {
-      return false;
+      return { ok: false, reason: 'network' };
     }
   },
 
@@ -1025,6 +1063,9 @@ export const PopupController = {
 
         const optBodies = optionLines.map(l => l.replace(/^([A-E])\s*[\)\.\-:]\s*/i, '').trim());
         const allOptTokens = normalizeTokens(optBodies.join(' ')).filter(t => !stopWords.has(t));
+        const stemContextTokens = normalizeTokens(stemLines.join(' '));
+        const acronymContextHints = new Set(['formato', 'arquivo', 'arquivos', 'extensao', 'documento', 'documentos', 'json', 'xml', 'bson', 'yaml', 'csv', 'dados']);
+        const hasAcronymContext = stemContextTokens.some((t) => acronymContextHints.has(t));
 
         // If options are ALL very short (Ôëñ6 chars each, e.g. BSON, XLS, XML),
         // they're likely acronyms from a completely different question domain.
@@ -1034,7 +1075,11 @@ export const PopupController = {
         if (allOptTokens.length === 0) {
           // All options are too short to produce tokens ÔÇö might be all-acronym
           if (allAcronym) {
-            console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD rejected options (all-acronym, no tokens). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
+            if (optionLines.length >= 4 && hasAcronymContext) {
+              console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD allowed options (all-acronym, contextual stem match). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
+              return true;
+            }
+            console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD rejected options (all-acronym, no contextual stem match). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
             return false;
           }
           return true;
@@ -1047,7 +1092,11 @@ export const PopupController = {
         const overlapRatio = sharedTokens / allOptTokens.length;
 
         if (allAcronym && overlapRatio === 0) {
-          console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD rejected options (all-acronym with 0 stem overlap). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
+          if (optionLines.length >= 4 && hasAcronymContext) {
+            console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD allowed options (all-acronym with contextual stem match). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
+            return true;
+          }
+          console.log(`AnswerHunter: OPTIONS_CONTAMINATION_GUARD rejected options (all-acronym with 0 stem overlap and no contextual stem match). Options: "${optionLines.slice(0, 3).join(' | ')}"`);
           return false;
         }
 
@@ -1448,7 +1497,29 @@ export const PopupController = {
                   for (const tk of anchorTokens) if (norm.includes(tk)) hits += 1;
                   if (hits < 4) continue;
 
-                  const extracted = extractOptionLines(raw);
+                  // Find the line where the question stem starts to avoid extracting options from previous questions
+                  const rawLines = raw.split(/\n/);
+                  let bestLineIdx = 0;
+                  let maxLineHits = 0;
+
+                  for (let i = 0; i < rawLines.length; i++) {
+                    const lineNorm = normalize(rawLines[i]);
+                    if (!lineNorm) continue;
+                    let lineHits = 0;
+                    for (const tk of anchorTokens) if (lineNorm.includes(tk)) lineHits++;
+
+                    if (lineHits > maxLineHits) {
+                      maxLineHits = lineHits;
+                      bestLineIdx = i;
+                      // Strong match found in this line, stop to avoid matching a repeated stem later
+                      if (lineHits >= 4) break;
+                    }
+                  }
+
+                  // Crop text from just before the matched line downwards
+                  const croppedRaw = rawLines.slice(Math.max(0, bestLineIdx - 1)).join('\n');
+
+                  const extracted = extractOptionLines(croppedRaw);
                   if (extracted.length < 2) continue;
 
                   const codeCount = extracted.filter((line) => {
@@ -1472,7 +1543,7 @@ export const PopupController = {
             const anchoredRelated = optionsAreContextuallyRelated(stemForOptions || bestQuestion, anchoredText);
             if (anchoredCount >= 2 && !anchoredRelated) {
               console.log(`AnswerHunter: HTML_ANCHORED_OPTIONS rejected=${anchoredCount} (context mismatch)`);
-            } else if (anchoredCount >= 2 && anchoredCount > currentCount) {
+            } else if (anchoredCount >= 2 && (anchoredCount >= currentCount || usedVisionOcr)) {
               optionsText = anchoredText;
               console.log(`AnswerHunter: HTML_ANCHORED_OPTIONS used=${anchoredCount} (replaced previous=${currentCount})`);
             } else if (anchoredCount >= 2) {
@@ -1906,6 +1977,7 @@ export const PopupController = {
         return;
       }
 
+      console.log('AnswerHunter: Final results to display:', finalResults);
       const withSaved = finalResults.map((item) => ({
         ...item,
         question: displayQuestion,
diff --git a/src/models/SettingsModel.js b/src/models/SettingsModel.js
index eb3684d..20a458c 100644
--- a/src/models/SettingsModel.js
+++ b/src/models/SettingsModel.js
@@ -28,6 +28,7 @@ export const SettingsModel = {
             gemini: false
         },
         minGroqIntervalMs: 2500,
+        minGeminiIntervalMs: 4200,
         consensusVotingEnabled: true, // Enable multi-attempt consensus
         consensusMinAttempts: 2, // Minimum attempts for consensus (2-3)
         consensusThreshold: 0.5 // Minimum vote ratio to accept (0.5 = 50%)
diff --git a/src/services/ApiService.js b/src/services/ApiService.js
index 3a765a4..f8817ab 100644
--- a/src/services/ApiService.js
+++ b/src/services/ApiService.js
@@ -1,4 +1,4 @@
-import { SettingsModel } from '../models/SettingsModel.js';
+´╗┐import { SettingsModel } from '../models/SettingsModel.js';
 
 /**
  * ApiService.js
@@ -7,9 +7,15 @@ import { SettingsModel } from '../models/SettingsModel.js';
 export const ApiService = {
     lastGroqCallAt: 0,
     _groqQueue: Promise.resolve(),
+    lastGeminiCallAt: 0,
+    _geminiQueue: Promise.resolve(),
     // When Groq returns retry-after > 90s, the quota is depleted at hourly/daily level.
     // All subsequent Groq calls should fail fast instead of hanging for minutes.
     _groqQuotaExhaustedUntil: 0,
+    // Gemini can be rate-limited globally at project level; avoid hammering repeated 429s.
+    _geminiRateLimitedUntil: 0,
+    _geminiQuotaExhaustedUntil: 0,
+    _geminiKeyFingerprint: '',
 
     /**
      * Call Gemini via its OpenAI-compatible endpoint.
@@ -23,61 +29,114 @@ export const ApiService = {
         const { geminiApiKey, geminiApiUrl, geminiModel } = settings;
         if (!geminiApiKey) return null;
 
+        const keyFingerprint = String(geminiApiKey).slice(-8);
+        if (this._geminiKeyFingerprint !== keyFingerprint) {
+            this._geminiKeyFingerprint = keyFingerprint;
+            this._geminiRateLimitedUntil = 0;
+            this._geminiQuotaExhaustedUntil = 0;
+            console.log(`AnswerHunter: Gemini key updated (fingerprint=...${keyFingerprint}) - cooldown reset`);
+        }
+
+        const now = Date.now();
+        if (this._geminiQuotaExhaustedUntil > now) {
+            const waitMin = Math.ceil((this._geminiQuotaExhaustedUntil - now) / 60000);
+            console.warn(`AnswerHunter: Gemini skipped - quota cooldown active (~${waitMin} min left)`);
+            return null;
+        }
+        if (this._geminiRateLimitedUntil > now) {
+            const waitSec = Math.ceil((this._geminiRateLimitedUntil - now) / 1000);
+            console.warn(`AnswerHunter: Gemini skipped - rate-limit cooldown active (${waitSec}s left)`);
+            return null;
+        }
+
         const model = opts.model || geminiModel || 'gemini-2.5-flash';
         const baseUrl = (geminiApiUrl || 'https://generativelanguage.googleapis.com/v1beta').replace(/\/+$/, '');
         const url = `${baseUrl}/openai/chat/completions`;
 
         const doCall = async (callModel) => {
-            try {
-                // Thinking models (gemini-2.5-pro, gemini-2.5-ultra) use "thinking tokens"
-                // that count against max_tokens. With 600-700 the model exhausts the
-                // budget on reasoning and returns empty content (finish=length).
-                const isThinkingModel = /pro|ultra/i.test(callModel) && /2\.5/i.test(callModel);
-                const effectiveMaxTokens = isThinkingModel
-                    ? Math.max(opts.max_tokens ?? 700, 4096)
-                    : (opts.max_tokens ?? 700);
-
-                const response = await fetch(url, {
-                    method: 'POST',
-                    headers: {
-                        'Authorization': `Bearer ${geminiApiKey}`,
-                        'Content-Type': 'application/json'
-                    },
-                    body: JSON.stringify({
-                        model: callModel,
-                        messages,
-                        temperature: opts.temperature ?? 0.1,
-                        max_tokens: effectiveMaxTokens
-                    })
-                });
+            const maxRetries = 3;
+            for (let attempt = 0; attempt < maxRetries; attempt++) {
+                try {
+                    // Thinking models (gemini-2.5-pro, gemini-2.5-ultra) use "thinking tokens"
+                    // that count against max_tokens. With 600-700 the model exhausts the
+                    // budget on reasoning and returns empty content (finish=length).
+                    const isThinkingModel = /pro|ultra/i.test(callModel) && /2\.5/i.test(callModel);
+                    const effectiveMaxTokens = isThinkingModel
+                        ? Math.max(opts.max_tokens ?? 700, 4096)
+                        : (opts.max_tokens ?? 700);
+
+                    const response = await this._withGeminiRateLimit(() => fetch(url, {
+                        method: 'POST',
+                        headers: {
+                            'Authorization': `Bearer ${geminiApiKey}`,
+                            'Content-Type': 'application/json'
+                        },
+                        body: JSON.stringify({
+                            model: callModel,
+                            messages,
+                            temperature: opts.temperature ?? 0.1,
+                            max_tokens: effectiveMaxTokens
+                        })
+                    }));
 
-                if (!response.ok) {
-                    const errText = await response.text().catch(() => '');
-                    console.warn(`AnswerHunter: Gemini HTTP ${response.status} (model=${callModel}): ${errText.slice(0, 200)}`);
-                    return null;
-                }
+                    if (!response.ok) {
+                        const retryAfterSec = parseFloat(response.headers.get('retry-after') || '0');
+                        const errText = await response.text().catch(() => '');
+                        const quotaExhausted = response.status === 429
+                            && /exceeded your current quota|plan and billing|quota/i.test(errText);
+
+                        if (response.status === 429 && quotaExhausted) {
+                            const cooldownMs = Math.max(
+                                retryAfterSec > 0 ? retryAfterSec * 1000 : 0,
+                                15 * 60 * 1000
+                            );
+                            this._geminiQuotaExhaustedUntil = Date.now() + cooldownMs;
+                            console.warn(`AnswerHunter: Gemini quota exhausted (429). Cooldown ${Math.round(cooldownMs / 60000)} min.`);
+                            return null;
+                        }
 
-                const data = await response.json();
-                const msg = data?.choices?.[0]?.message;
-                // Thinking models (gemini-2.5-pro) may put content in reasoning_content
-                let content = msg?.content?.trim() || '';
-                if (!content && msg?.reasoning_content) {
-                    content = String(msg.reasoning_content).trim();
-                    console.log(`AnswerHunter: Gemini used reasoning_content (model=${callModel}, ${content.length} chars)`);
-                }
-                if (!content) {
-                    // Log response structure for diagnostics
-                    const msgKeys = msg ? Object.keys(msg).join(',') : 'no-message';
-                    const finishReason = data?.choices?.[0]?.finish_reason || 'unknown';
-                    console.warn(`AnswerHunter: Gemini empty content (model=${callModel}, finish=${finishReason}, msgKeys=[${msgKeys}])`);
+                        if (response.status === 429 && attempt < maxRetries - 1) {
+                            const backoffMs = Math.max(
+                                retryAfterSec > 0 ? retryAfterSec * 1000 : 0,
+                                Math.pow(2, attempt + 1) * 1000 + (Math.random() * 500)
+                            );
+                            this._geminiRateLimitedUntil = Date.now() + Math.min(backoffMs, 30000);
+                            console.log(`AnswerHunter: Gemini 429 Rate Limit, waiting ${Math.round(backoffMs)}ms (attempt ${attempt + 1}/${maxRetries})...`);
+                            await new Promise(r => setTimeout(r, backoffMs));
+                            continue;
+                        }
+
+                        console.warn(`AnswerHunter: Gemini HTTP ${response.status} (model=${callModel}): ${errText.slice(0, 240)}`);
+                        return null;
+                    }
+
+                    this._geminiRateLimitedUntil = 0;
+                    const data = await response.json();
+                    const msg = data?.choices?.[0]?.message;
+                    // Thinking models (gemini-2.5-pro) may put content in reasoning_content
+                    let content = msg?.content?.trim() || '';
+                    if (!content && msg?.reasoning_content) {
+                        content = String(msg.reasoning_content).trim();
+                        console.log(`AnswerHunter: Gemini used reasoning_content (model=${callModel}, ${content.length} chars)`);
+                    }
+                    if (!content) {
+                        // Log response structure for diagnostics
+                        const msgKeys = msg ? Object.keys(msg).join(',') : 'no-message';
+                        const finishReason = data?.choices?.[0]?.finish_reason || 'unknown';
+                        console.warn(`AnswerHunter: Gemini empty content (model=${callModel}, finish=${finishReason}, msgKeys=[${msgKeys}])`);
+                        return null;
+                    }
+                    console.log(`AnswerHunter: Gemini success (model=${callModel}, ${content.length} chars)`);
+                    console.log(`  [Gemini Raw Response]:`, content);
+                    return content;
+                } catch (err) {
+                    const errMsg = err?.message || String(err);
+                    if (errMsg.includes('GEMINI_QUOTA_EXHAUSTED')) return null;
+                    console.warn(`AnswerHunter: Gemini error (model=${callModel}):`, errMsg);
                     return null;
                 }
-                console.log(`AnswerHunter: Gemini success (model=${callModel}, ${content.length} chars)`);
-                return content;
-            } catch (err) {
-                console.warn(`AnswerHunter: Gemini error (model=${callModel}):`, err?.message || String(err));
-                return null;
-            }
+            } // end retry loop
+            return null;
         };
 
         // Primary attempt
@@ -87,7 +146,7 @@ export const ApiService = {
         // Auto-downgrade: if smart/pro model returned empty, retry with flash
         const flashModel = geminiModel || 'gemini-2.5-flash';
         if (model !== flashModel && /pro|ultra/i.test(model) && !opts._noDowngrade) {
-            console.log(`AnswerHunter: Gemini auto-downgrade ${model} ÔåÆ ${flashModel}`);
+            console.log(`AnswerHunter: Gemini auto-downgrade ${model} -> ${flashModel}`);
             result = await doCall(flashModel);
             if (result) return result;
         }
@@ -169,7 +228,7 @@ export const ApiService = {
 
         // If smart model returned ALL nulls and it's different from flash, auto-downgrade
         if (nullCount >= temps.length && smartModel !== flashModel && /pro|ultra/i.test(smartModel)) {
-            console.log(`AnswerHunter: Gemini consensus auto-downgrade ${smartModel} ÔåÆ ${flashModel}`);
+            console.log(`AnswerHunter: Gemini consensus auto-downgrade ${smartModel} ├»┬┐┬¢  ${flashModel}`);
             const fallback = await runConsensusLoop(flashModel, [0.1, 0.3]);
             votes = { ...votes, ...fallback.votes };
             // Merge responses keeping longest
@@ -209,10 +268,10 @@ export const ApiService = {
         let noValidCount = 0;
 
         for (const temp of temps) {
-            // Fast-fail check BEFORE each attempt ÔÇö don't waste calls after exhaustion
+            // Fast-fail check BEFORE each attempt ├»┬┐┬¢ don't waste calls after exhaustion
             if (this._groqQuotaExhaustedUntil > Date.now()) {
                 const waitMin = Math.ceil((this._groqQuotaExhaustedUntil - Date.now()) / 60000);
-                console.warn(`AnswerHunter: Groq consensus skipping temp=${temp} ÔÇö quota exhausted (~${waitMin}min left)`);
+                console.warn(`AnswerHunter: Groq consensus skipping temp=${temp} ├»┬┐┬¢ quota exhausted (~${waitMin}min left)`);
                 break;
             }
             try {
@@ -234,6 +293,7 @@ export const ApiService = {
                 }));
 
                 const content = data?.choices?.[0]?.message?.content?.trim() || '';
+                console.log(`  [Groq Consensus Attempt]:`, content);
                 if (!content || content.length < 3 || /^(NAO_ENCONTRADO|SEM_RESPOSTA|INCONCLUSIVO)/i.test(content)) {
                     noValidCount += 1;
                     continue;
@@ -299,6 +359,29 @@ export const ApiService = {
         this._groqQueue = task.catch(() => { });
         return task;
     },
+    async _waitForGeminiRateLimit() {
+        const { minGeminiIntervalMs } = await this._getSettings();
+        const intervalMs = Math.max(350, Number(minGeminiIntervalMs) || 4200);
+        const now = Date.now();
+        const elapsed = now - this.lastGeminiCallAt;
+        const remaining = intervalMs - elapsed;
+        if (remaining > 0) {
+            await new Promise(resolve => setTimeout(resolve, remaining));
+        }
+        this.lastGeminiCallAt = Date.now();
+    },
+    async _withGeminiRateLimit(taskFn) {
+        const run = async () => {
+            if (this._geminiQuotaExhaustedUntil > Date.now()) {
+                throw new Error('GEMINI_QUOTA_EXHAUSTED');
+            }
+            await this._waitForGeminiRateLimit();
+            return taskFn();
+        };
+        const task = this._geminiQueue.then(run, run);
+        this._geminiQueue = task.catch(() => { });
+        return task;
+    },
 
     /**
      * Wrapper for fetch with common headers and robust retry
@@ -316,31 +399,31 @@ export const ApiService = {
                     const retryAfter = parseFloat(response.headers.get('retry-after') || '0');
 
                     // If Groq says wait > 30s, the quota is approaching exhaustion.
-                    // Flag it and fail immediately ÔÇö do NOT waste retries.
+                    // Flag it and fail immediately ├»┬┐┬¢ do NOT waste retries.
                     if (retryAfter > 30) {
                         this._groqQuotaExhaustedUntil = Date.now() + retryAfter * 1000;
                         const waitMin = Math.ceil(retryAfter / 60);
-                        console.warn(`AnswerHunter: Groq quota EXHAUSTED ÔÇö retry-after=${retryAfter}s (~${waitMin}min). Skipping all Groq calls.`);
+                        console.warn(`AnswerHunter: Groq quota EXHAUSTED ├»┬┐┬¢ retry-after=${retryAfter}s (~${waitMin}min). Skipping all Groq calls.`);
                         throw new Error(`GROQ_QUOTA_EXHAUSTED: retry-after=${retryAfter}s (~${waitMin}min)`);
                     }
 
-                    // Short retry-after (< 30s): per-minute rate limit, wait once and retry
-                    if (attempt < maxRetries - 1 && retryAfter > 0 && retryAfter <= 30) {
-                        const backoffMs = Math.ceil(retryAfter * 1000) + 500;
-                        console.log(`AnswerHunter: Rate limit 429, aguardando ${backoffMs}ms (retry-after=${retryAfter}s, tentativa ${attempt + 1}/${maxRetries})...`);
+                    // Short retry-after (< 30s) or no retry-after: per-minute rate limit, wait and retry
+                    if (attempt < maxRetries - 1 && retryAfter <= 30) {
+                        const delaySec = retryAfter > 0 ? retryAfter : Math.pow(2, attempt) + 1;
+                        const backoffMs = Math.ceil(delaySec * 1000) + 500 + Math.random() * 500;
+                        console.log(`AnswerHunter: Rate limit 429, aguardando ${Math.round(backoffMs)}ms (retry-after=${retryAfter}s, tentativa ${attempt + 1}/${maxRetries})...`);
                         await new Promise(resolve => setTimeout(resolve, backoffMs));
                         continue;
                     }
 
-                    // No retry-after or zero: flag as quota problem anyway
-                    this._groqQuotaExhaustedUntil = Date.now() + 120000; // assume 2min
-                    console.warn('AnswerHunter: Groq 429 without retry-after ÔÇö assuming quota exhausted for 2min');
-                    throw new Error('GROQ_QUOTA_EXHAUSTED: 429 without retry-after');
+                    // Otherwise, if it's the last attempt or >30s without retry-after.
+                    console.warn(`AnswerHunter: Groq 429 limit exhausted (retries=${attempt + 1}, retry-after=${retryAfter})`);
+                    throw new Error('GROQ_QUOTA_EXHAUSTED: 429 max retries reached');
                 }
 
                 throw new Error(`HTTP Error ${response.status}`);
             } catch (error) {
-                // Never retry quota-exhaustion ÔÇö the flag is already set, retrying just wastes 429s
+                // Never retry quota-exhaustion ├»┬┐┬¢ the flag is already set, retrying just wastes 429s
                 const isQuotaError = error.message?.includes('GROQ_QUOTA_EXHAUSTED');
                 if (attempt < maxRetries - 1 && !isQuotaError && !error.message?.includes('HTTP Error')) {
                     const jitter = 500 + Math.random() * 500;
@@ -412,7 +495,7 @@ export const ApiService = {
             // If preview still carries substantial educational content (question + alternatives),
             // treat as readable instead of blocked.
             const optionMatches = text.match(/(?:^|\s)[a-e]\s*[\)\.\-:]\s+/gim) || [];
-            const hasQuestionLanguage = /\b(?:assinale|quest(?:ao|├úo)|alternativa|afirmativa|aula\s+\d+)\b/i.test(text);
+            const hasQuestionLanguage = /\b(?:assinale|quest(?:ao|├â┬úo)|alternativa|afirmativa|aula\s+\d+)\b/i.test(text);
             return text.length > 3500 && optionMatches.length >= 3 && hasQuestionLanguage;
         })();
 
@@ -438,7 +521,7 @@ export const ApiService = {
         }
     },
 
-    // Shared webcache 429 tracking ÔÇö skip cache after too many consecutive 429s.
+    // Shared webcache 429 tracking ├»┬┐┬¢ skip cache after too many consecutive 429s.
     _webcache429Count: 0,
     _webcache429Threshold: 2,
     resetWebcache429() {
@@ -447,7 +530,7 @@ export const ApiService = {
 
     /**
      * AI-powered per-page deep answer extraction.
-     * Sends page text + question to AI for a "pente fino" ÔÇö deep analysis.
+     * Sends page text + question to AI for a "pente fino" ├»┬┐┬¢ deep analysis.
      * Uses SMART model for best accuracy. Prefers Gemini (free, higher limits).
      * @param {string} pageText - Page text (will be truncated to ~8000 chars)
      * @param {string} questionText - The question with options
@@ -456,7 +539,7 @@ export const ApiService = {
      */
     async aiExtractFromPage(pageText, questionText, hostHint = '') {
         if (!pageText || pageText.length < 100 || !questionText) {
-            console.log(`  ­ƒö¼ [aiExtract] SKIP: text too short (${(pageText || '').length} chars)`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] SKIP: text too short (${(pageText || '').length} chars)`);
             return null;
         }
 
@@ -464,96 +547,39 @@ export const ApiService = {
         const truncatedPage = pageText.substring(0, 8000);
         const truncatedQuestion = questionText.substring(0, 1800);
 
-        console.log(`  ­ƒö¼ [aiExtract] START host=${hostHint} pageLen=${truncatedPage.length} questionLen=${truncatedQuestion.length}`);
-
-        const systemMsg = `Voc├¬ ├® um especialista em encontrar respostas de quest├Áes de m├║ltipla escolha dentro de textos acad├¬micos. Analise o texto fornecido com rigor. Responda APENAS com base no texto ÔÇö nunca invente informa├º├Áes.`;
-
-        const prompt = `# Tarefa
-Analise o TEXTO abaixo e encontre a resposta para a QUEST├âO do aluno.
-
-# ATEN├ç├âO CR├ìTICA: P├íginas com m├║ltiplas quest├Áes
-O texto pode conter V├üRIAS quest├Áes sobre o mesmo tema. Voc├¬ DEVE:
-- Comparar o ENUNCIADO EXATO e as ALTERNATIVAS EXATAS da quest├úo do aluno
-- Se encontrar um gabarito, confirmar que ele pertence ├á quest├úo CERTA (mesmo enunciado, mesmas alternativas)
-- NUNCA usar gabarito/resposta de uma quest├úo DIFERENTE, mesmo que trate do mesmo assunto
-
-# O que procurar (em ordem de prioridade)
-1. Gabarito expl├¡cito: "Gabarito: X", "Resposta: X", "Alternativa correta: X", marca├º├úo Ô£ô/Ôÿà
-2. Resolu├º├úo da quest├úo: explica├º├úo que conclua em uma alternativa
-3. Quest├úo id├¬ntica/similar com resposta em outro local do texto
-4. Defini├º├Áes ou conceitos que confirmem/refutem alternativas
-5. Informa├º├Áes acad├¬micas relevantes ao tema
-
-# Formato de resposta (siga EXATAMENTE um dos tr├¬s)
-
-## Se encontrou a resposta:
-RESULTADO: ENCONTRADO
-EVID├èNCIA: [trecho exato copiado do texto]
-RACIOC├ìNIO: [como o trecho leva ├á resposta, passo a passo]
-Letra X: [texto da alternativa]
-
-## Se h├í conhecimento ├║til mas sem resposta definitiva:
-RESULTADO: CONHECIMENTO_PARCIAL
-CONHECIMENTOS: [fatos/conceitos encontrados, relevantes ├á quest├úo]
+        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] START host=${hostHint} pageLen=${truncatedPage.length} questionLen=${truncatedQuestion.length}`);
 
-## Se n├úo encontrou nada ├║til:
-RESULTADO: NAO_ENCONTRADO
+        const systemMsg = `Voce e especialista em encontrar resposta de multipla escolha em texto. Nunca invente.`;
 
-# Exemplos
+        const prompt = `TAREFA:
+Analise o TEXTO e responda a QUESTAO do aluno.
+Se houver varias questoes na pagina, use apenas a que bate com enunciado + alternativas do aluno.
 
-<exemplo_1>
-TEXTO: "...Quest├úo 5. O modelo relacional utiliza chaves prim├írias para identificar registros. Gabarito: C..."
-QUEST├âO: "No modelo relacional, o que identifica unicamente um registro? A) ├ìndice B) View C) Chave prim├íria D) Trigger"
-
-RESULTADO: ENCONTRADO
-EVID├èNCIA: "Gabarito: C"
-RACIOC├ìNIO: O texto cont├®m o gabarito expl├¡cito da quest├úo 5 indicando letra C.
-Letra C: Chave prim├íria
-</exemplo_1>
-
-<exemplo_2>
-TEXTO: "...NoSQL prioriza escalabilidade horizontal e flexibilidade de esquema, sacrificando consist├¬ncia forte em favor de disponibilidade (teorema CAP)..."
-QUEST├âO: "Qual fator ├® mais importante para o desempenho de bancos NoSQL? A) Normaliza├º├úo B) Joins complexos C) Escalabilidade horizontal D) ACID completo"
-
-RESULTADO: ENCONTRADO
-EVID├èNCIA: "NoSQL prioriza escalabilidade horizontal e flexibilidade de esquema"
-RACIOC├ìNIO: Passo 1: O texto afirma que NoSQL prioriza escalabilidade horizontal. Passo 2: A alternativa C menciona exatamente "escalabilidade horizontal". Passo 3: As alternativas A, B e D s├úo caracter├¡sticas de bancos relacionais, n├úo NoSQL.
-Letra C: Escalabilidade horizontal
-</exemplo_2>
-
-<exemplo_3>
-TEXTO: "...O sistema imunol├│gico possui c├®lulas T e c├®lulas B que atuam na defesa adaptativa..."
-QUEST├âO: "Qual a capital da Fran├ºa? A) Londres B) Paris C) Berlim"
-
-RESULTADO: NAO_ENCONTRADO
-</exemplo_3>
+FORMATO OBRIGATORIO (um):
+1) RESULTADO: ENCONTRADO
+EVIDENCIA: [trecho literal do texto]
+RACIOCINIO: [passos curtos]
+Letra X: [texto da alternativa]
 
-<exemplo_4>
-TEXTO: "...Quest├úo 3. Marque a op├º├úo falsa sobre diferen├ºas NoSQL vs relacional: a) Grafos ... e) Escalabilidade horizontal. Gabarito: E. Quest├úo 4. Assinale o fator importante para o desempenho de bancos NoSQL: a) Ser schemaless b) SQL..."
-QUEST├âO: "Assinale o fator importante para o desempenho de bancos NoSQL: A) Ser schemaless B) SQL C) Escalabilidade vertical D) Transa├º├Áes E) Chave-valor"
+2) RESULTADO: CONHECIMENTO_PARCIAL
+CONHECIMENTOS: [fatos relevantes]
 
-RESULTADO: NAO_ENCONTRADO
-(O "Gabarito: E" no texto pertence ├á Quest├úo 3 ÔÇö uma quest├úo DIFERENTE com alternativas DIFERENTES. A Quest├úo 4 n├úo tem gabarito no texto.)
-</exemplo_4>
+3) RESULTADO: NAO_ENCONTRADO
 
-ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ
 TEXTO (${hostHint}):
 ${truncatedPage}
-ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ
-QUEST├âO:
-${truncatedQuestion}
-ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ
 
-Analise o texto passo a passo e responda no formato acima:`;
+QUESTAO:
+${truncatedQuestion}`;
 
-        /* ---------- Try Gemini (preferred ÔÇö free, higher limits) ---------- */
+        /* ---------- Try Gemini (preferred ├»┬┐┬¢ free, higher limits) ---------- */
         const tryGemini = async () => {
             if (!settings.geminiApiKey) {
-                console.log(`  ­ƒö¼ [aiExtract] Gemini: no API key`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Gemini: no API key`);
                 return null;
             }
             try {
-                console.log(`  ­ƒö¼ [aiExtract] Trying Gemini (${settings.geminiModelSmart || 'gemini-2.5-flash'})...`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Trying Gemini (${settings.geminiModelSmart || 'gemini-2.5-flash'})...`);
                 const result = await this._callGemini([
                     { role: 'system', content: systemMsg },
                     { role: 'user', content: prompt }
@@ -562,44 +588,47 @@ Analise o texto passo a passo e responda no formato acima:`;
                     max_tokens: 300,
                     model: 'gemini-2.5-flash' // Force fast model for heavy extraction loop
                 });
-                console.log(`  ­ƒö¼ [aiExtract] Gemini response: ${result ? result.length + ' chars' : 'null'}`);
-                if (result) console.log(`  ­ƒö¼ [aiExtract] Gemini preview: "${result.substring(0, 200)}"`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Gemini response: ${result ? result.length + ' chars' : 'null'}`);
+                if (result) console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Gemini preview: "${result.substring(0, 200)}"`);
                 return result;
             } catch (e) {
-                console.warn(`  ­ƒö¼ [aiExtract] Gemini error:`, e?.message || e);
+                console.warn(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Gemini error:`, e?.message || e);
                 return null;
             }
         };
 
         /* ---------- Try Groq (backup) ---------- */
         const tryGroq = async () => {
-            const { groqApiUrl, groqApiKey, groqModelSmart } = settings;
+            const { groqApiUrl, groqApiKey, groqModelFast, groqModelSmart } = settings;
             if (!groqApiKey) {
-                console.log(`  ­ƒö¼ [aiExtract] Groq: no API key`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Groq: no API key`);
                 return null;
             }
             if (this._groqQuotaExhaustedUntil > Date.now()) {
-                console.log(`  ­ƒö¼ [aiExtract] Groq: quota exhausted, skipping`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Groq: quota exhausted, skipping`);
                 return null;
             }
+            // Estrategia 4: Rebaixamento Inteligente de LLM. Tarefas de escaneamento em
+            // 8000 caracteres n├â┬úo precisam do 70B versatil. O 8B Instant resolve em 0.5s.
+            const targetModel = groqModelFast || 'llama-3.1-8b-instant';
             try {
-                console.log(`  ­ƒö¼ [aiExtract] Trying Groq (${groqModelSmart})...`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Trying Groq (${targetModel}) instead of (${groqModelSmart}) for speed...`);
                 const data = await this._withGroqRateLimit(() => this._fetch(groqApiUrl, {
                     method: 'POST',
                     headers: { 'Authorization': `Bearer ${groqApiKey}`, 'Content-Type': 'application/json' },
                     body: JSON.stringify({
-                        model: groqModelSmart,
+                        model: targetModel,
                         messages: [{ role: 'system', content: systemMsg }, { role: 'user', content: prompt }],
                         temperature: 0.05,
                         max_tokens: 300
                     })
                 }));
                 const result = data?.choices?.[0]?.message?.content?.trim() || null;
-                console.log(`  ­ƒö¼ [aiExtract] Groq response: ${result ? result.length + ' chars' : 'null'}`);
-                if (result) console.log(`  ­ƒö¼ [aiExtract] Groq preview: "${result.substring(0, 200)}"`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Groq response: ${result ? result.length + ' chars' : 'null'}`);
+                if (result) console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Groq preview: "${result.substring(0, 200)}"`);
                 return result;
             } catch (e) {
-                console.warn(`  ­ƒö¼ [aiExtract] Groq error:`, e?.message || e);
+                console.warn(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Groq error:`, e?.message || e);
                 return null;
             }
         };
@@ -632,21 +661,21 @@ Analise o texto passo a passo e responda no formato acima:`;
             }
             // If provider returned null (likely quota error or crash) or explicitly NAO_ENCONTRADO,
             // we loop to the next provider in the chain.
-            console.log(`  ­ƒö¼ [aiExtract] ${provider.name} failed or NAO_ENCONTRADO, trying next fallback...`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] ${provider.name} failed or NAO_ENCONTRADO, trying next fallback...`);
         }
 
         if (!content || content.length < 10) {
-            console.log(`  ­ƒö¼ [aiExtract] RESULT: no response from any provider`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] RESULT: no response from any provider`);
             return null;
         }
 
         /* ---------- Parse response ---------- */
-        // Check for CONHECIMENTO_PARCIAL ÔÇö useful info but no definitive answer
+        // Check for CONHECIMENTO_PARCIAL ├»┬┐┬¢ useful info but no definitive answer
         if (/RESULTADO:\s*CONHECIMENTO_PARCIAL/i.test(content)) {
             const knowledgeMatch = content.match(/CONHECIMENTOS?:\s*([\s\S]+)/i);
             const knowledge = knowledgeMatch ? knowledgeMatch[1].trim().substring(0, 1200) : content.substring(0, 1200);
-            console.log(`  ­ƒö¼ [aiExtract] RESULT: PARTIAL KNOWLEDGE (${knowledge.length} chars)`);
-            console.log(`  ­ƒö¼ [aiExtract] Knowledge preview: "${knowledge.substring(0, 200)}"`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] RESULT: PARTIAL KNOWLEDGE (${knowledge.length} chars)`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] Knowledge preview: "${knowledge.substring(0, 200)}"`);
             return {
                 letter: null,
                 evidence: null,
@@ -658,7 +687,7 @@ Analise o texto passo a passo e responda no formato acima:`;
 
         // Check for NAO_ENCONTRADO
         if (/RESULTADO:\s*NAO_ENCONTRADO/i.test(content)) {
-            console.log(`  ­ƒö¼ [aiExtract] RESULT: NAO_ENCONTRADO`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] RESULT: NAO_ENCONTRADO`);
             return null;
         }
 
@@ -667,7 +696,7 @@ Analise o texto passo a passo e responda no formato acima:`;
             || content.match(/\b([A-E])\s*[\):\.\-]\s*\S/);
         if (!letterMatch) {
             // No letter but might have useful knowledge
-            console.log(`  ­ƒö¼ [aiExtract] RESULT: response but no letter found. Treating as knowledge.`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] RESULT: response but no letter found. Treating as knowledge.`);
             return {
                 letter: null,
                 evidence: null,
@@ -678,9 +707,9 @@ Analise o texto passo a passo e responda no formato acima:`;
         }
 
         const letter = letterMatch[1].toUpperCase();
-        const evidenceMatch = content.match(/EVID[E├è]NCIA:\s*([\s\S]*?)(?=RACIOC[I├ì]NIO:|Letra\s+[A-E]|$)/i);
+        const evidenceMatch = content.match(/EVID[E├»┬┐┬¢`]NCIA:\s*([\s\S]*?)(?=RACIOC[I├â┬ì]NIO:|Letra\s+[A-E]|$)/i);
         const evidence = evidenceMatch ? evidenceMatch[1].trim() : content;
-        console.log(`  ­ƒö¼ [aiExtract] RESULT: FOUND letter=${letter} evidence="${evidence.substring(0, 150)}"`);
+        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [aiExtract] RESULT: FOUND letter=${letter} evidence="${evidence.substring(0, 150)}"`);
 
         return {
             letter,
@@ -706,61 +735,61 @@ Analise o texto passo a passo e responda no formato acima:`;
 
         const knowledgeSection = knowledgePool
             .slice(0, 8)
-            .map((k, i) => `FONTE ${i + 1} (${k.host}, relev├óncia=${(k.topicSim || 0).toFixed(2)}):\n${String(k.knowledge || '').substring(0, 1500)}`)
-            .join('\n\nÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\n\n');
+            .map((k, i) => `FONTE ${i + 1} (${k.host}, relev├â┬óncia=${(k.topicSim || 0).toFixed(2)}):\n${String(k.knowledge || '').substring(0, 1500)}`)
+            .join('\n\n├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢\n\n');
 
         const totalKnowledge = knowledgePool.reduce((sum, k) => sum + (k.knowledge || '').length, 0);
-        console.log(`  ­ƒºá [aiReflect] START: ${knowledgePool.length} sources, ${totalKnowledge} total knowledge chars`);
+        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] START: ${knowledgePool.length} sources, ${totalKnowledge} total knowledge chars`);
 
-        const systemMsg = `Voc├¬ ├® um professor universit├írio. Analise as informa├º├Áes das fontes para responder a quest├úo. Use seu conhecimento acad├¬mico para complementar quando necess├írio. IGNORE quaisquer indica├º├Áes de "Letra", "Gabarito" ou "Resposta" que estejam nas fontes ÔÇö essas podem ser de quest├Áes diferentes. Avalie cada alternativa de forma independente com base nos FATOS. Responda APENAS no formato solicitado.`;
+        const systemMsg = `Voc├â┬¬ ├â┬® um professor universit├â┬írio. Analise as informa├â┬º├â┬Áes das fontes para responder a quest├â┬úo. Use seu conhecimento acad├â┬¬mico para complementar quando necess├â┬írio. IGNORE quaisquer indica├â┬º├â┬Áes de "Letra", "Gabarito" ou "Resposta" que estejam nas fontes ├»┬┐┬¢ essas podem ser de quest├â┬Áes diferentes. Avalie cada alternativa de forma independente com base nos FATOS. Responda APENAS no formato solicitado.`;
 
         const prompt = `# Tarefa
-V├írias p├íginas foram analisadas e nenhuma tinha a resposta definitiva. Abaixo est├úo os CONHECIMENTOS EXTRA├ìDOS de cada fonte. Combine essas informa├º├Áes para inferir a resposta.
+V├â┬írias p├â┬íginas foram analisadas e nenhuma tinha a resposta definitiva. Abaixo est├â┬úo os CONHECIMENTOS EXTRA├â┬ìDOS de cada fonte. Combine essas informa├â┬º├â┬Áes para inferir a resposta.
 
 # Fontes
 ${knowledgeSection}
 
-# Quest├úo
+# Quest├â┬úo
 ${questionText.substring(0, 1800)}
 
-# M├®todo (siga passo a passo)
+# M├â┬®todo (siga passo a passo)
 
-PASSO 1 ÔÇö COMPILAR: Liste os fatos-chave de TODAS as fontes acima.
-PASSO 2 ÔÇö AVALIAR: Para cada alternativa, indique se as fontes CONFIRMAM, REFUTAM ou s├úo INCERTAS.
-PASSO 3 ÔÇö ELIMINAR: Descarte alternativas refutadas pelas fontes.
-PASSO 4 ÔÇö CONCLUIR: Se restar apenas uma vi├ível, essa ├® a resposta. Se n├úo, declare INCONCLUSIVO.
+PASSO 1 ├»┬┐┬¢ COMPILAR: Liste os fatos-chave de TODAS as fontes acima.
+PASSO 2 ├»┬┐┬¢ AVALIAR: Para cada alternativa, indique se as fontes CONFIRMAM, REFUTAM ou s├â┬úo INCERTAS.
+PASSO 3 ├»┬┐┬¢ ELIMINAR: Descarte alternativas refutadas pelas fontes.
+PASSO 4 ├»┬┐┬¢ CONCLUIR: Se restar apenas uma vi├â┬ível, essa ├â┬® a resposta. Se n├â┬úo, declare INCONCLUSIVO.
 
 # Exemplo
 
 <exemplo>
-Fontes dizem: "TCP usa handshake de 3 vias", "UDP n├úo garante entrega"
-Quest├úo: "Qual protocolo garante entrega? A) UDP B) TCP C) ICMP"
+Fontes dizem: "TCP usa handshake de 3 vias", "UDP n├â┬úo garante entrega"
+Quest├â┬úo: "Qual protocolo garante entrega? A) UDP B) TCP C) ICMP"
 
-PASSO 1: TCP usa handshake 3 vias (fonte 1). UDP n├úo garante entrega (fonte 2).
+PASSO 1: TCP usa handshake 3 vias (fonte 1). UDP n├â┬úo garante entrega (fonte 2).
 PASSO 2:
-A) UDP ÔÇö REFUTADA (fonte 2 diz que n├úo garante entrega)
-B) TCP ÔÇö CONFIRMADA (handshake 3 vias = garantia de entrega)
-C) ICMP ÔÇö INCERTA (nenhuma fonte menciona)
-PASSO 3: A eliminada. C sem evid├¬ncia. B confirmada.
-PASSO 4: Apenas B ├® vi├ível.
+A) UDP ├»┬┐┬¢ REFUTADA (fonte 2 diz que n├â┬úo garante entrega)
+B) TCP ├»┬┐┬¢ CONFIRMADA (handshake 3 vias = garantia de entrega)
+C) ICMP ├»┬┐┬¢ INCERTA (nenhuma fonte menciona)
+PASSO 3: A eliminada. C sem evid├â┬¬ncia. B confirmada.
+PASSO 4: Apenas B ├â┬® vi├â┬ível.
 
-CONCLUS├âO:
+CONCLUS├âÔÇÖO:
 Letra B: TCP
 </exemplo>
 
-# Sua an├ílise (siga os 4 passos):`;
+# Sua an├â┬ílise (siga os 4 passos):`;
 
         /* ---------- Try Gemini first (free, no quota concern) ---------- */
         const tryGemini = async () => {
             if (!settings.geminiApiKey) return null;
             try {
-                console.log(`  ­ƒºá [aiReflect] Trying Gemini (${settings.geminiModelSmart || 'gemini-2.5-flash'})...`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] Trying Gemini (${settings.geminiModelSmart || 'gemini-2.5-flash'})...`);
                 return await this._callGemini([
                     { role: 'system', content: systemMsg },
                     { role: 'user', content: prompt }
                 ], { temperature: 0.1, max_tokens: 800, model: settings.geminiModelSmart || 'gemini-2.5-flash' });
             } catch (e) {
-                console.warn(`  ­ƒºá [aiReflect] Gemini error:`, e?.message || e);
+                console.warn(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] Gemini error:`, e?.message || e);
                 return null;
             }
         };
@@ -768,7 +797,7 @@ Letra B: TCP
         const tryGroq = async () => {
             if (!settings.groqApiKey || this._groqQuotaExhaustedUntil > Date.now()) return null;
             try {
-                console.log(`  ­ƒºá [aiReflect] Trying Groq (${settings.groqModelSmart})...`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] Trying Groq (${settings.groqModelSmart})...`);
                 const data = await this._withGroqRateLimit(() => this._fetch(settings.groqApiUrl, {
                     method: 'POST',
                     headers: { 'Authorization': `Bearer ${settings.groqApiKey}`, 'Content-Type': 'application/json' },
@@ -780,7 +809,7 @@ Letra B: TCP
                 }));
                 return data?.choices?.[0]?.message?.content?.trim() || null;
             } catch (e) {
-                console.warn(`  ­ƒºá [aiReflect] Groq error:`, e?.message || e);
+                console.warn(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] Groq error:`, e?.message || e);
                 return null;
             }
         };
@@ -803,22 +832,22 @@ Letra B: TCP
         }
 
         if (!content || content.length < 20) {
-            console.log(`  ­ƒºá [aiReflect] RESULT: no response`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] RESULT: no response`);
             return null;
         }
 
-        console.log(`  ­ƒºá [aiReflect] Response (${content.length} chars): "${content.substring(0, 300)}"`);
+        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] Response (${content.length} chars): "${content.substring(0, 300)}"`);
 
         // Parse letter
         const letterMatch = content.match(/\bLetra\s+([A-E])\b/i)
-            || content.match(/CONCLUS[A├â]O:[\s\S]*?\b([A-E])\s*[\):\.\-]/i);
+            || content.match(/CONCLUS[A├âÔÇÖ]O:[\s\S]*?\b([A-E])\s*[\):\.\-]/i);
         if (!letterMatch) {
-            console.log(`  ­ƒºá [aiReflect] RESULT: response but no letter (INCONCLUSIVO?)`);
+            console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] RESULT: response but no letter (INCONCLUSIVO?)`);
             return null;
         }
 
         const letter = letterMatch[1].toUpperCase();
-        console.log(`  ­ƒºá [aiReflect] RESULT: letter=${letter}`);
+        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [aiReflect] RESULT: letter=${letter}`);
         return { letter, response: content, method: 'ai-combined-reflection' };
     },
 
@@ -877,7 +906,7 @@ Letra B: TCP
                 if (is429) {
                     this._webcache429Count += 1;
                     if (this._webcache429Count >= this._webcache429Threshold) {
-                        console.log(`ApiService: Webcache rate-limited (${this._webcache429Count} consecutive 429s) ÔÇö will skip cache for remaining URLs`);
+                        console.log(`ApiService: Webcache rate-limited (${this._webcache429Count} consecutive 429s) ├»┬┐┬¢ will skip cache for remaining URLs`);
                     }
                 } else if (cached.ok) {
                     this._webcache429Count = 0; // Reset on success.
@@ -1092,12 +1121,12 @@ Letra B: TCP
         const { groqApiUrl, groqApiKey, groqModelVision } = settings;
 
         const promptText = [
-            'Voc├¬ ├® um OCR especializado em provas educacionais.',
-            'Extraia APENAS a quest├úo (enunciado + alternativas A-E) que est├í mais centralizada/vis├¡vel na imagem.',
-            'Se houver m├║ltiplas quest├Áes, escolha a que est├í mais ao centro da tela.',
-            'Retorne o texto puro da quest├úo com as alternativas, sem nenhum coment├írio adicional.',
+            'Voc├â┬¬ ├â┬® um OCR especializado em provas educacionais.',
+            'Extraia APENAS a quest├â┬úo (enunciado + alternativas A-E) que est├â┬í mais centralizada/vis├â┬¡vel na imagem.',
+            'Se houver m├â┬║ltiplas quest├â┬Áes, escolha a que est├â┬í mais ao centro da tela.',
+            'Retorne o texto puro da quest├â┬úo com as alternativas, sem nenhum coment├â┬írio adicional.',
             'Formato esperado:',
-            '<enunciado da quest├úo>',
+            '<enunciado da quest├â┬úo>',
             'A) <texto>',
             'B) <texto>',
             'C) <texto>',
@@ -1124,7 +1153,7 @@ Letra B: TCP
             if (!settings.geminiApiKey) return null;
             try {
                 const model = settings.geminiModel || 'gemini-2.5-flash';
-                console.log(`AnswerHunter: Vision OCR ÔÇö sending screenshot to Gemini (${model})...`);
+                console.log(`AnswerHunter: Vision OCR ├»┬┐┬¢ sending screenshot to Gemini (${model})...`);
                 const content = await this._callGemini(visionMessages, {
                     temperature: 0.1,
                     max_tokens: 700,
@@ -1134,7 +1163,7 @@ Letra B: TCP
                     console.warn('AnswerHunter: Gemini Vision OCR returned too little text:', (content || '').length);
                     return null;
                 }
-                console.log(`AnswerHunter: Gemini Vision OCR success ÔÇö ${content.length} chars extracted`);
+                console.log(`AnswerHunter: Gemini Vision OCR success ├»┬┐┬¢ ${content.length} chars extracted`);
                 return content;
             } catch (e) {
                 console.warn('AnswerHunter: Gemini Vision OCR failed:', e?.message || e);
@@ -1146,7 +1175,7 @@ Letra B: TCP
             if (!groqApiKey || this._groqQuotaExhaustedUntil > Date.now()) return null;
             const model = groqModelVision || 'meta-llama/llama-4-scout-17b-16e-instruct';
             try {
-                console.log(`AnswerHunter: Vision OCR ÔÇö sending screenshot to Groq (${model})...`);
+                console.log(`AnswerHunter: Vision OCR ├»┬┐┬¢ sending screenshot to Groq (${model})...`);
                 const data = await this._withGroqRateLimit(() => this._fetch(groqApiUrl, {
                     method: 'POST',
                     headers: {
@@ -1166,7 +1195,7 @@ Letra B: TCP
                     console.warn('AnswerHunter: Groq Vision OCR returned too little text:', content.length);
                     return null;
                 }
-                console.log(`AnswerHunter: Groq Vision OCR success ÔÇö ${content.length} chars extracted`);
+                console.log(`AnswerHunter: Groq Vision OCR success ├»┬┐┬¢ ${content.length} chars extracted`);
                 return content;
             } catch (e) {
                 console.warn('AnswerHunter: Groq Vision OCR failed:', e?.message || e);
@@ -1629,7 +1658,7 @@ Letra B: TCP
             const seenQueries = new Set();
             let serperCalls = 0;
 
-            // ÔòÉÔòÉÔòÉ Google AI Overview / AnswerBox / PeopleAlsoAsk capture ÔòÉÔòÉÔòÉ
+            // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ Google AI Overview / AnswerBox / PeopleAlsoAsk capture ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
             // Serper may return these rich fields alongside organic results.
             // We capture the FIRST occurrence across all Serper calls and attach
             // it to the returned array as `_serperMeta` for downstream processing.
@@ -1773,13 +1802,13 @@ Letra B: TCP
             return options.length >= 2 ? options : null;
         };
 
-        // IMPROVED method for alternatives without letter (Est├ício/Brainly format)
+        // IMPROVED method for alternatives without letter (Est├â┬ício/Brainly format)
         // Detects consecutive sentences that appear to be options after markers
         const bySentencesAfterMarker = () => {
             // Search for option start markers
             const markers = [
                 /(?:assinale|marque)\s+(?:a\s+)?(?:alternativa\s+)?(?:correta|verdadeira|incorreta|falsa)[.:]/gi, ,
-                /(?:op├º├úo|alternativa)\s+(?:correta|verdadeira)[.:]/gi,
+                /(?:op├â┬º├â┬úo|alternativa)\s+(?:correta|verdadeira)[.:]/gi,
                 /\(Ref\.?:\s*\d+\)/gi,
                 /assinale\s+(?:a\s+)?(?:afirmativa|assertiva)\s+correta[.:]/gi
             ];
@@ -1821,7 +1850,7 @@ Letra B: TCP
                     // Remove sentences that look like answers/keys
                     if (/^(Resposta|Gabarito|Correta|A resposta|portanto|letra\s+[A-E]|De acordo|Segundo)/i.test(s)) return false;
                     // Remove sentences with site metadata
-                    if (/verificad[ao]|especialista|winnyfernandes|Excelente|curtidas|usu├írio|respondeu/i.test(s)) return false;
+                    if (/verificad[ao]|especialista|winnyfernandes|Excelente|curtidas|usu├â┬írio|respondeu/i.test(s)) return false;
                     return true;
                 });
 
@@ -1846,13 +1875,13 @@ Letra B: TCP
                 const line = lines[i];
 
                 // Marks start of options section
-                if (/assinale|alternativa|op├º├úo|op├º├Áes|correta[.:]|incorreta[.:]/i.test(line)) {
+                if (/assinale|alternativa|op├â┬º├â┬úo|op├â┬º├â┬Áes|correta[.:]|incorreta[.:]/i.test(line)) {
                     foundStartMarker = true;
                     continue;
                 }
 
                 // Stops when finding answer markers
-                if (/^(Resposta|Gabarito|Correta|Alternativa correta|A resposta|est├í correta|portanto|letra\s+[A-E])/i.test(line)) {
+                if (/^(Resposta|Gabarito|Correta|Alternativa correta|A resposta|est├â┬í correta|portanto|letra\s+[A-E])/i.test(line)) {
                     break;
                 }
 
@@ -1998,54 +2027,54 @@ E) [texto da alternativa E se houver]`;
 
         const prompts = [
             // Prompt 1: Direct extraction
-            `Analise a fonte e identifique a resposta correta para a quest├úo.
+            `Analise a fonte e identifique a resposta correta para a quest├â┬úo.
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${originalQuestion.substring(0, 1500)}
 
 FONTE:
 ${sourceContent.substring(0, 2500)}
 
-INSTRU├ç├òES:
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES:
 - Identifique a letra da resposta correta (A, B, C, D ou E)
 - Extraia o texto completo da alternativa correta
 - Responda APENAS no formato: "Letra X: [texto completo da alternativa]"
-- Se n├úo encontrar resposta clara, diga apenas: NAO_ENCONTRADO`,
+- Se n├â┬úo encontrar resposta clara, diga apenas: NAO_ENCONTRADO`,
 
             // Prompt 2: Step-by-step reasoning
-            `AN├üLISE PASSO A PASSO:
+            `AN├â┬üLISE PASSO A PASSO:
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${originalQuestion.substring(0, 1500)}
 
 FONTE:
 ${sourceContent.substring(0, 2500)}
 
-PASSO 1: A fonte cont├®m um gabarito expl├¡cito ("gabarito:", "resposta:", etc.)? Qual letra?
-PASSO 2: Se n├úo houver gabarito expl├¡cito, qual alternativa ├® confirmada como correta pela fonte?
+PASSO 1: A fonte cont├â┬®m um gabarito expl├â┬¡cito ("gabarito:", "resposta:", etc.)? Qual letra?
+PASSO 2: Se n├â┬úo houver gabarito expl├â┬¡cito, qual alternativa ├â┬® confirmada como correta pela fonte?
 PASSO 3: Resposta final no formato: "Letra X: [texto]"
 
-Se n├úo houver evid├¬ncia: NAO_ENCONTRADO`,
+Se n├â┬úo houver evid├â┬¬ncia: NAO_ENCONTRADO`,
 
             // Prompt 3: Evidence-based
-            `IDENTIFICA├ç├âO POR EVID├èNCIAS:
+            `IDENTIFICA├»┬┐┬¢!├âÔÇÖO POR EVID├»┬┐┬¢`NCIAS:
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${originalQuestion.substring(0, 1500)}
 
 FONTE:
 ${sourceContent.substring(0, 2500)}
 
 Busque na fonte:
-1. Marca├º├Áes expl├¡citas: "gabarito", "correta", "resposta"
-2. Explica├º├Áes que confirmam uma alternativa espec├¡fica
-3. Coment├írios de professores/especialistas
+1. Marca├â┬º├â┬Áes expl├â┬¡citas: "gabarito", "correta", "resposta"
+2. Explica├â┬º├â┬Áes que confirmam uma alternativa espec├â┬¡fica
+3. Coment├â┬írios de professores/especialistas
 
 Formato de resposta: "Letra X: [texto]"
 Se incerto: NAO_ENCONTRADO`
         ];
 
-        const systemMsg = 'Voc├¬ extrai respostas de quest├Áes de m├║ltipla escolha. Sempre responda no formato "Letra X: [texto da alternativa]".';
+        const systemMsg = 'Voc├â┬¬ extrai respostas de quest├â┬Áes de m├â┬║ltipla escolha. Sempre responda no formato "Letra X: [texto da alternativa]".';
 
         const runGroqConsensus = async () => {
             if (!groqApiKey || this._groqQuotaExhaustedUntil > Date.now()) return [];
@@ -2158,25 +2187,25 @@ Se incerto: NAO_ENCONTRADO`
         }
 
         // Fallback to single attempt with more explicit prompt
-        const prompt = `Analise a fonte e identifique a resposta correta para a quest├úo.
+        const prompt = `Analise a fonte e identifique a resposta correta para a quest├â┬úo.
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${originalQuestion.substring(0, 1500)}
 
 FONTE:
 ${sourceContent.substring(0, 2500)}
 
-INSTRU├ç├òES:
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES:
 - Identifique a letra da resposta correta (A, B, C, D ou E)
 - Extraia o texto completo da alternativa correta
 - Responda APENAS no formato: "Letra X: [texto completo da alternativa]"
-- Se n├úo encontrar resposta clara, diga apenas: NAO_ENCONTRADO`;
+- Se n├â┬úo encontrar resposta clara, diga apenas: NAO_ENCONTRADO`;
 
-        const systemMsg = 'Voc├¬ extrai respostas de quest├Áes de m├║ltipla escolha. Sempre responda no formato "Letra X: [texto da alternativa]".';
+        const systemMsg = 'Voc├â┬¬ extrai respostas de quest├â┬Áes de m├â┬║ltipla escolha. Sempre responda no formato "Letra X: [texto da alternativa]".';
 
         const parseResponse = (content) => {
             if (!content || content.length < 3) return null;
-            if (/^(NAO_ENCONTRADO|SEM_RESPOSTA|INVALIDO|N[├úa]o\s+(encontr|consigo|h[├ía]))/i.test(content)) return null;
+            if (/^(NAO_ENCONTRADO|SEM_RESPOSTA|INVALIDO|N[├â┬úa]o\s+(encontr|consigo|h[├â┬ía]))/i.test(content)) return null;
             if (/NAO_ENCONTRADO|SEM_RESPOSTA/i.test(content)) return null;
             return content;
         };
@@ -2255,62 +2284,62 @@ INSTRU├ç├òES:
         const normQ = originalQuestion.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
         const wantsIncorrect = /\b(falsa|incorreta|errada|exceto|nao\s+correta)\b/i.test(normQ);
         const polarityNote = wantsIncorrect
-            ? '\nÔÜá´©Å ATEN├ç├âO: A quest├úo pede a alternativa INCORRETA/FALSA/EXCETO. Voc├¬ deve encontrar a alternativa ERRADA, n├úo a correta.'
+            ? '\n├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å ATEN├»┬┐┬¢!├âÔÇÖO: A quest├â┬úo pede a alternativa INCORRETA/FALSA/EXCETO. Voc├â┬¬ deve encontrar a alternativa ERRADA, n├â┬úo a correta.'
             : '';
 
-        const basePrompt = `INFER├èNCIA DE RESPOSTA COM BASE EM EVID├èNCIAS
+        const basePrompt = `INFER├»┬┐┬¢`NCIA DE RESPOSTA COM BASE EM EVID├»┬┐┬¢`NCIAS
 
-QUEST├âO DO CLIENTE:
+QUEST├âÔÇÖO DO CLIENTE:
 ${originalQuestion.substring(0, 2000)}
 
-EVID├èNCIAS DAS FONTES:
+EVID├»┬┐┬¢`NCIAS DAS FONTES:
 ${sourceContent.substring(0, 3500)}
 ${polarityNote}
 
-INSTRU├ç├òES - siga EXATAMENTE esta ordem:
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES - siga EXATAMENTE esta ordem:
 
 PASSO 1: Leitura atenta do enunciado
-- Identifique o ASPECTO ESPEC├ìFICO que a quest├úo pede (ex: desempenho, seguran├ºa, flexibilidade, etc.).
-- A quest├úo pede a alternativa CORRETA ou INCORRETA/FALSA/EXCETO?
-- N├úo basta uma alternativa ser "verdadeira" ÔÇö ela precisa responder ao que o ENUNCIADO pergunta.
+- Identifique o ASPECTO ESPEC├â┬ìFICO que a quest├â┬úo pede (ex: desempenho, seguran├â┬ºa, flexibilidade, etc.).
+- A quest├â┬úo pede a alternativa CORRETA ou INCORRETA/FALSA/EXCETO?
+- N├â┬úo basta uma alternativa ser "verdadeira" ├»┬┐┬¢ ela precisa responder ao que o ENUNCIADO pergunta.
 
-PASSO 2: An├ílise das evid├¬ncias/explica├º├Áes das fontes
-- Procure textos explicativos, justificativas ou defini├º├Áes nas fontes.
+PASSO 2: An├â┬ílise das evid├â┬¬ncias/explica├â┬º├â┬Áes das fontes
+- Procure textos explicativos, justificativas ou defini├â┬º├â┬Áes nas fontes.
 - Identifique trechos que mencionem conceitos presentes nas alternativas.
-- Conecte cada trecho explicativo ├á alternativa que ele descreve.
-- IMPORTANTE: Preste aten├º├úo em frases como "isso se deve a...", "o motivo ├®...", "por conta de...", que revelam a rela├º├úo causal.
+- Conecte cada trecho explicativo ├â┬á alternativa que ele descreve.
+- IMPORTANTE: Preste aten├â┬º├â┬úo em frases como "isso se deve a...", "o motivo ├â┬®...", "por conta de...", que revelam a rela├â┬º├â┬úo causal.
 
-PASSO 3: Classifica├º├úo de cada alternativa
+PASSO 3: Classifica├â┬º├â┬úo de cada alternativa
 Para cada alternativa (A-E):
-- Essa alternativa trata do ASPECTO ESPEC├ìFICO pedido no enunciado? (sim/n├úo)
-- As evid├¬ncias CONFIRMAM ou REFUTAM essa alternativa para o aspecto pedido?
-- Classifique como V (verdadeira E responde ao enunciado) ou F (falsa OU n├úo responde ao aspecto pedido).
+- Essa alternativa trata do ASPECTO ESPEC├â┬ìFICO pedido no enunciado? (sim/n├â┬úo)
+- As evid├â┬¬ncias CONFIRMAM ou REFUTAM essa alternativa para o aspecto pedido?
+- Classifique como V (verdadeira E responde ao enunciado) ou F (falsa OU n├â┬úo responde ao aspecto pedido).
 
 PASSO 4: Resposta FINAL
-- Se apenas UMA alternativa ├® V e responde ao aspecto pedido, essa ├® a resposta.
-- Se m├║ltiplas s├úo V, releia o enunciado e escolha a mais PRECISA para o aspecto pedido.
-- Se as fontes t├¬m texto explicativo que aponta para uma alternativa, PRIORIZE essa evid├¬ncia.
+- Se apenas UMA alternativa ├â┬® V e responde ao aspecto pedido, essa ├â┬® a resposta.
+- Se m├â┬║ltiplas s├â┬úo V, releia o enunciado e escolha a mais PRECISA para o aspecto pedido.
+- Se as fontes t├â┬¬m texto explicativo que aponta para uma alternativa, PRIORIZE essa evid├â┬¬ncia.
 
-FORMATO FINAL OBRIGAT├ôRIO (├║ltima linha):
+FORMATO FINAL OBRIGAT├»┬┐┬¢RIO (├â┬║ltima linha):
 Letra X: [texto completo da alternativa]
 
-Se n├úo houver evid├¬ncia suficiente: NAO_ENCONTRADO
+Se n├â┬úo houver evid├â┬¬ncia suficiente: NAO_ENCONTRADO
 
 REGRAS:
-- Nunca invente alternativas que n├úo estejam na quest├úo do cliente.
-- O ENUNCIADO define o crit├®rio: responda ao que ele PERGUNTA, n├úo ao que parece "mais correto" em geral.
-- Textos explicativos/justificativos nas fontes s├úo a evid├¬ncia mais valiosa ÔÇö use-os.
+- Nunca invente alternativas que n├â┬úo estejam na quest├â┬úo do cliente.
+- O ENUNCIADO define o crit├â┬®rio: responda ao que ele PERGUNTA, n├â┬úo ao que parece "mais correto" em geral.
+- Textos explicativos/justificativos nas fontes s├â┬úo a evid├â┬¬ncia mais valiosa ├»┬┐┬¢ use-os.
 ${isDesperate ? `
-ATEN├ç├âO - EVID├èNCIA LIMITADA:
-As fontes acima cont├¬m informa├º├úo limitada e podem n├úo ter a resposta expl├¡cita.
-Nesse caso, use seu CONHECIMENTO ACAD├èMICO para avaliar cada alternativa:
-- Foque EXCLUSIVAMENTE no ASPECTO ESPEC├ìFICO pedido no enunciado (ex: "desempenho", "seguran├ºa", etc.).
-- Uma alternativa pode ser VERDADEIRA sobre o tema geral mas N├âO responder ao aspecto espec├¡fico pedido.
-- Exemplo: se a quest├úo pede sobre "desempenho", caracter├¡sticas de "flexibilidade" ou "linguagem" N├âO s├úo sobre desempenho.
+ATEN├»┬┐┬¢!├âÔÇÖO - EVID├»┬┐┬¢`NCIA LIMITADA:
+As fontes acima cont├â┬¬m informa├â┬º├â┬úo limitada e podem n├â┬úo ter a resposta expl├â┬¡cita.
+Nesse caso, use seu CONHECIMENTO ACAD├»┬┐┬¢`MICO para avaliar cada alternativa:
+- Foque EXCLUSIVAMENTE no ASPECTO ESPEC├â┬ìFICO pedido no enunciado (ex: "desempenho", "seguran├â┬ºa", etc.).
+- Uma alternativa pode ser VERDADEIRA sobre o tema geral mas N├âÔÇÖO responder ao aspecto espec├â┬¡fico pedido.
+- Exemplo: se a quest├â┬úo pede sobre "desempenho", caracter├â┬¡sticas de "flexibilidade" ou "linguagem" N├âÔÇÖO s├â┬úo sobre desempenho.
 - Elimine primeiro alternativas factualmente INCORRETAS.
-- Depois, entre as corretas, escolha a que tem rela├º├úo CAUSAL DIRETA com o aspecto pedido.
-- O modelo de transa├º├Áes (ACID vs BASE) afeta diretamente throughput/lat├¬ncia = desempenho.
-- Schemaless afeta flexibilidade, n├úo desempenho. Escalabilidade horizontal Ôëá vertical.` : ''}`;
+- Depois, entre as corretas, escolha a que tem rela├â┬º├â┬úo CAUSAL DIRETA com o aspecto pedido.
+- O modelo de transa├â┬º├â┬Áes (ACID vs BASE) afeta diretamente throughput/lat├â┬¬ncia = desempenho.
+- Schemaless afeta flexibilidade, n├â┬úo desempenho. Escalabilidade horizontal ├»┬┐┬¢0├»┬┐┬¢ vertical.` : ''}`;
 
         // Consensus with controlled temperature diversity.
         // Routes to primary provider first, then fallback.
@@ -2322,20 +2351,20 @@ Nesse caso, use seu CONHECIMENTO ACAD├èMICO para avaliar cada alternativa:
             await new Promise(resolve => setTimeout(resolve, waitMs));
         }
 
-        const systemMsg = 'Voc├¬ infere respostas de quest├Áes educacionais com base em evid├¬ncias de fontes. Analise textos explicativos, justificativas e defini├º├Áes nas fontes para encontrar qual alternativa responde ao ASPECTO ESPEC├ìFICO do enunciado. N├úo se limite a verificar se uma alternativa ├® "verdadeira" ÔÇö ela precisa responder ao que o enunciado PERGUNTA. Formato final: "Letra X: [texto]" ou NAO_ENCONTRADO.';
+        const systemMsg = 'Voc├â┬¬ infere respostas de quest├â┬Áes educacionais com base em evid├â┬¬ncias de fontes. Analise textos explicativos, justificativas e defini├â┬º├â┬Áes nas fontes para encontrar qual alternativa responde ao ASPECTO ESPEC├â┬ìFICO do enunciado. N├â┬úo se limite a verificar se uma alternativa ├â┬® "verdadeira" ├»┬┐┬¢ ela precisa responder ao que o enunciado PERGUNTA. Formato final: "Letra X: [texto]" ou NAO_ENCONTRADO.';
         const letterPattern = /(?:Letra|Letter)\s*([A-E])[:\s\)]/i;
         const geminiPrimary = await this._isGeminiPrimary();
 
         if (geminiPrimary) {
-            // ÔöÇÔöÇ Gemini PRIMARY ÔåÆ Groq fallback ÔöÇÔöÇ
+            // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Gemini PRIMARY ├»┬┐┬¢  Groq fallback ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
             console.log('AnswerHunter: Inference via Gemini (primary)...');
             const gResult = await this._geminiConsensus(systemMsg, basePrompt, letterPattern, { smart: true });
             if (gResult.response) {
                 console.log('AnswerHunter: Gemini primary inference votes:', gResult.votes);
                 return gResult.response;
             }
-            // Gemini failed ÔåÆ try Groq fallback
-            console.log('AnswerHunter: Gemini primary failed ÔÇö trying Groq fallback...');
+            // Gemini failed ├»┬┐┬¢  try Groq fallback
+            console.log('AnswerHunter: Gemini primary failed ├»┬┐┬¢ trying Groq fallback...');
             const groqResult = await this._groqConsensus(systemMsg, basePrompt, letterPattern, { model: groqModelSmart });
             if (groqResult.response) {
                 console.log('AnswerHunter: Groq fallback inference votes:', groqResult.votes);
@@ -2344,15 +2373,15 @@ Nesse caso, use seu CONHECIMENTO ACAD├èMICO para avaliar cada alternativa:
             return null;
         }
 
-        // ÔöÇÔöÇ Groq PRIMARY ÔåÆ Gemini fallback ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Groq PRIMARY ├»┬┐┬¢  Gemini fallback ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         console.log('AnswerHunter: Inference via Groq (primary)...');
         const groqResult = await this._groqConsensus(systemMsg, basePrompt, letterPattern, { model: groqModelSmart });
         if (groqResult.response && groqResult.attempts.length > 0) {
             console.log('AnswerHunter: Groq primary inference votes:', groqResult.votes);
             return groqResult.response;
         }
-        // Groq failed ÔåÆ try Gemini fallback
-        console.log('AnswerHunter: Groq primary failed ÔÇö trying Gemini fallback...');
+        // Groq failed ├»┬┐┬¢  try Gemini fallback
+        console.log('AnswerHunter: Groq primary failed ├»┬┐┬¢ trying Gemini fallback...');
         const geminiResult = await this._geminiConsensus(systemMsg, basePrompt, letterPattern, { smart: true });
         if (geminiResult.response) {
             console.log('AnswerHunter: Gemini fallback inference votes:', geminiResult.votes);
@@ -2383,15 +2412,15 @@ Nesse caso, use seu CONHECIMENTO ACAD├èMICO para avaliar cada alternativa:
             })
             .join('\n\n');
 
-        const prompt = `Voc├¬ vai gerar um overview curto e ├║til (estilo Google AI Overview), SEM inventar fatos.
+        const prompt = `Voc├â┬¬ vai gerar um overview curto e ├â┬║til (estilo Google AI Overview), SEM inventar fatos.
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${String(questionText).slice(0, 1800)}
 
-EVID├èNCIAS:
+EVID├»┬┐┬¢`NCIAS:
 ${compactEvidence}
 
-RETORNE APENAS JSON v├ílido no formato:
+RETORNE APENAS JSON v├â┬ílido no formato:
 {
   "summary": "resumo em 2-4 frases, objetivo",
   "keyPoints": ["ponto 1", "ponto 2", "ponto 3"],
@@ -2401,13 +2430,13 @@ RETORNE APENAS JSON v├ílido no formato:
 }
 
 REGRAS:
-- Use apenas o que est├í nas evid├¬ncias.
+- Use apenas o que est├â┬í nas evid├â┬¬ncias.
 - Se houver conflito ou baixa clareza, mencione isso no summary.
-- keyPoints: no m├íximo 4 itens.
-- references: no m├íximo 5 itens.
-- N├úo inclua markdown, coment├írio ou texto fora do JSON.`;
+- keyPoints: no m├â┬íximo 4 itens.
+- references: no m├â┬íximo 5 itens.
+- N├â┬úo inclua markdown, coment├â┬írio ou texto fora do JSON.`;
 
-        const sysMsg = 'Voc├¬ transforma evid├¬ncias em resumo estruturado e confi├ível. Nunca invente links, cita├º├Áes ou fatos fora da entrada.';
+        const sysMsg = 'Voc├â┬¬ transforma evid├â┬¬ncias em resumo estruturado e confi├â┬ível. Nunca invente links, cita├â┬º├â┬Áes ou fatos fora da entrada.';
 
         /** Parse overview JSON from raw response */
         const parseOverview = (raw, modelLabel) => {
@@ -2434,7 +2463,7 @@ REGRAS:
         const geminiPrimary = await this._isGeminiPrimary();
 
         if (geminiPrimary) {
-            // ÔöÇÔöÇ Gemini PRIMARY for overview ÔöÇÔöÇ
+            // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Gemini PRIMARY for overview ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
             try {
                 console.log('AnswerHunter: Overview via Gemini (primary)...');
                 const geminiRaw = await this._callGemini([
@@ -2447,10 +2476,10 @@ REGRAS:
                 console.warn('AnswerHunter: Gemini primary overview failed:', gErr?.message || String(gErr));
             }
             // Fallback to Groq
-            console.log('AnswerHunter: Gemini overview failed ÔÇö trying Groq fallback...');
+            console.log('AnswerHunter: Gemini overview failed ├»┬┐┬¢ trying Groq fallback...');
         }
 
-        // ÔöÇÔöÇ Groq overview (primary or fallback) ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Groq overview (primary or fallback) ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         for (const model of modelCandidates) {
             const sinceLast = Date.now() - this.lastGroqCallAt;
             if (sinceLast < 3000) {
@@ -2484,10 +2513,10 @@ REGRAS:
             }
         }
 
-        // ÔöÇÔöÇ Gemini fallback for overview (when Groq was primary) ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Gemini fallback for overview (when Groq was primary) ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         if (!geminiPrimary) {
             try {
-                console.log('AnswerHunter: Groq overview failed ÔÇö trying Gemini fallback...');
+                console.log('AnswerHunter: Groq overview failed ├»┬┐┬¢ trying Gemini fallback...');
                 const geminiRaw = await this._callGemini([
                     { role: 'system', content: sysMsg },
                     { role: 'user', content: prompt }
@@ -2505,7 +2534,7 @@ REGRAS:
     /**
      * Knowledge-based answer: uses LLM domain expertise when evidence is thin.
      * Runs in parallel with inferAnswerFromEvidence during desperate mode.
-     * Single call, no consensus needed ÔÇö acts as a tiebreaker vote.
+     * Single call, no consensus needed ├»┬┐┬¢ acts as a tiebreaker vote.
      */
     async generateKnowledgeAnswer(questionText) {
         if (!questionText) return null;
@@ -2515,34 +2544,34 @@ REGRAS:
         const normQ = questionText.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
         const wantsIncorrect = /\b(falsa|incorreta|errada|exceto|nao\s+correta)\b/i.test(normQ);
         const polarityNote = wantsIncorrect
-            ? '\nÔÜá´©Å A quest├úo pede a alternativa INCORRETA/FALSA/EXCETO.'
+            ? '\n├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å A quest├â┬úo pede a alternativa INCORRETA/FALSA/EXCETO.'
             : '';
 
-        const prompt = `AN├üLISE ACAD├èMICA POR ELIMINA├ç├âO
+        const prompt = `AN├â┬üLISE ACAD├»┬┐┬¢`MICA POR ELIMINA├»┬┐┬¢!├âÔÇÖO
 
-Voc├¬ ├® um professor universit├írio especialista. Use EXCLUSIVAMENTE seu conhecimento acad├¬mico.
+Voc├â┬¬ ├â┬® um professor universit├â┬írio especialista. Use EXCLUSIVAMENTE seu conhecimento acad├â┬¬mico.
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${questionText.substring(0, 2000)}
 ${polarityNote}
 
-INSTRU├ç├òES ÔÇö siga esta ordem RIGOROSA:
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES ├»┬┐┬¢ siga esta ordem RIGOROSA:
 
-1. ASPECTO PEDIDO: Identifique qual aspecto espec├¡fico o enunciado pergunta (ex: desempenho, seguran├ºa, modelo, etc.).
+1. ASPECTO PEDIDO: Identifique qual aspecto espec├â┬¡fico o enunciado pergunta (ex: desempenho, seguran├â┬ºa, modelo, etc.).
 
-2. ELIMINA├ç├âO: Para cada alternativa, an├ílise em 1 linha:
-   - ├ë factualmente CORRETA? Se N├âO ÔåÆ eliminada.
-   - Trata DIRETAMENTE do aspecto pedido? Se N├âO ÔåÆ eliminada (mesmo sendo verdadeira).
-   Formato: "X) ELIMINADA ÔÇö [motivo]" ou "X) MANTIDA ÔÇö [rela├º├úo com o aspecto]"
+2. ELIMINA├»┬┐┬¢!├âÔÇÖO: Para cada alternativa, an├â┬ílise em 1 linha:
+   - ├»┬┐┬¢0 factualmente CORRETA? Se N├âÔÇÖO ├»┬┐┬¢  eliminada.
+   - Trata DIRETAMENTE do aspecto pedido? Se N├âÔÇÖO ├»┬┐┬¢  eliminada (mesmo sendo verdadeira).
+   Formato: "X) ELIMINADA ├»┬┐┬¢ [motivo]" ou "X) MANTIDA ├»┬┐┬¢ [rela├â┬º├â┬úo com o aspecto]"
 
-3. SELE├ç├âO FINAL: Entre as mantidas, escolha a que tem rela├º├úo CAUSAL mais direta com o aspecto.
-   - N├úo escolha a "mais famosa" ÔÇö escolha a mais ESPEC├ìFICA para o aspecto pedido.
+3. SELE├»┬┐┬¢!├âÔÇÖO FINAL: Entre as mantidas, escolha a que tem rela├â┬º├â┬úo CAUSAL mais direta com o aspecto.
+   - N├â┬úo escolha a "mais famosa" ├»┬┐┬¢ escolha a mais ESPEC├â┬ìFICA para o aspecto pedido.
 
-FORMATO FINAL (├║ltima linha):
+FORMATO FINAL (├â┬║ltima linha):
 Letra X: [texto completo da alternativa]
 Ou: NAO_ENCONTRADO`;
 
-        const systemMsg = 'Voc├¬ ├® um professor universit├írio especialista em an├ílise de quest├Áes. Responda com rigor acad├¬mico, focando no ASPECTO ESPEC├ìFICO que o enunciado pede. N├úo escolha a alternativa mais popular ÔÇö escolha a mais precisa para o aspecto pedido.';
+        const systemMsg = 'Voc├â┬¬ ├â┬® um professor universit├â┬írio especialista em an├â┬ílise de quest├â┬Áes. Responda com rigor acad├â┬¬mico, focando no ASPECTO ESPEC├â┬ìFICO que o enunciado pede. N├â┬úo escolha a alternativa mais popular ├»┬┐┬¢ escolha a mais precisa para o aspecto pedido.';
         const isValid = (c) => c && c.length >= 3 && !/^(NAO_ENCONTRADO|SEM_RESPOSTA|INCONCLUSIVO)/i.test(c);
 
         const geminiPrimary = await this._isGeminiPrimary();
@@ -2582,7 +2611,7 @@ Ou: NAO_ENCONTRADO`;
             return null;
         };
 
-        /* ---------- primary ÔåÆ fallback ---------- */
+        /* ---------- primary ├»┬┐┬¢  fallback ---------- */
         if (geminiPrimary) {
             const res = await tryGemini();
             if (res) return res;
@@ -2651,43 +2680,52 @@ Ou: NAO_ENCONTRADO`;
         const hasOptions = /\b[A-E]\s*[).\-]\s/m.test(questionText);
 
         const prompt = hasOptions
-            ? `AN├üLISE SISTEM├üTICA DE QUEST├âO DE M├ÜLTIPLA ESCOLHA
+            ? `AN├â┬üLISE SISTEM├â┬üTICA DE QUEST├âÔÇÖO DE M├»┬┐┬¢aLTIPLA ESCOLHA
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${questionText}
 
-INSTRU├ç├òES - siga EXATAMENTE esta ordem:
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES - siga EXATAMENTE esta ordem:
+
+PASSO 1: CONTEXTO - Analise os comandos, c├â┬│digos e exemplos apresentados no enunciado da quest├â┬úo.
+- Identifique a tecnologia/SGBD espec├â┬¡fico (ex: MongoDB, PostgreSQL, Cassandra, Redis, Neo4j).
+- Comandos como "use", "db.collection", ".find()", ".insert()" = MongoDB.
+- Comandos como "CREATE TABLE", "SELECT", "jsonb_pretty" = PostgreSQL/SQL.
+- A resposta DEVE ser compat├â┬¡vel com a tecnologia identificada no enunciado.
 
-PASSO 1: Classifique CADA alternativa como V (verdadeira) ou F (falsa), com uma justificativa OBJETIVA de 1 linha baseada em fatos/defini├º├Áes.
-Formato: "X) V/F - [justificativa]"
+PASSO 2: Classifique CADA alternativa como V (verdadeira) ou F (falsa), com uma justificativa OBJETIVA de 1 linha baseada em fatos/defini├â┬º├â┬Áes.
+- IMPORTANTE: Uma alternativa pode ser tecnicamente correta em OUTRA tecnologia mas ERRADA no contexto da quest├â┬úo.
+Formato: "X) V/F - [justificativa considerando o contexto tecnol├â┬│gico]"
 
-PASSO 2: Verifique contradi├º├Áes:
-- H├í duas alternativas dizendo a mesma coisa? 
-- A quest├úo pede a CORRETA ou a INCORRETA/FALSA/EXCETO?
+PASSO 3: Verifique contradi├â┬º├â┬Áes:
+- H├â┬í duas alternativas dizendo a mesma coisa?
+- A quest├â┬úo pede a CORRETA ou a INCORRETA/FALSA/EXCETO?
+- Alguma alternativa mistura sintaxe de tecnologias diferentes (ex: SELECT com .find())?
 
-PASSO 3: Com base nos passos anteriores, indique a resposta FINAL.
-Se a quest├úo pede a CORRETA: escolha a alternativa V.
-Se a quest├úo pede a INCORRETA/FALSA/EXCETO: escolha a alternativa F.
+PASSO 4: Com base nos passos anteriores, indique a resposta FINAL.
+Se a quest├â┬úo pede a CORRETA: escolha a alternativa V.
+Se a quest├â┬úo pede a INCORRETA/FALSA/EXCETO: escolha a alternativa F.
 
-FORMATO FINAL (├║ltima linha):
-- Se houver seguran├ºa razo├ível: "Letra X: [texto completo da alternativa escolhida]"
-- Se n├úo houver seguran├ºa suficiente: "INCONCLUSIVO: sem evid├¬ncia suficiente para marcar alternativa"
+FORMATO FINAL (├â┬║ltima linha):
+- Se houver seguran├â┬ºa razo├â┬ível: "Letra X: [texto completo da alternativa escolhida]"
+- Se n├â┬úo houver seguran├â┬ºa suficiente: "INCONCLUSIVO: sem evid├â┬¬ncia suficiente para marcar alternativa"
 
 REGRAS:
-- Nunca invente alternativas que n├úo estejam na quest├úo.
-- Se houver d├║vida real entre duas alternativas, use INCONCLUSIVO.
-- Preste aten├º├úo especial se a quest├úo pede "incorreta", "falsa", "exceto" ou "n├úo ├®".`
-            : `Responda a quest├úo abaixo de forma direta e objetiva.\n\nQUEST├âO:\n${questionText}\n\nREGRAS:\n- Responda em 1 a 3 frases.\n- N├úo invente cita├º├Áes.`;
+- Nunca invente alternativas que n├â┬úo estejam na quest├â┬úo.
+- Se houver d├â┬║vida real entre duas alternativas, use INCONCLUSIVO.
+- Preste aten├â┬º├â┬úo especial se a quest├â┬úo pede "incorreta", "falsa", "exceto" ou "n├â┬úo ├â┬®".
+- Alternativas que misturam sintaxe SQL (SELECT) com sintaxe NoSQL (db.find) s├â┬úo SEMPRE falsas.`
+            : `Responda a quest├â┬úo abaixo de forma direta e objetiva.\n\nQUEST├âÔÇÖO:\n${questionText}\n\nREGRAS:\n- Responda em 1 a 3 frases.\n- N├â┬úo invente cita├â┬º├â┬Áes.`;
 
         // For multiple choice, try primary provider first then fallback
         if (hasOptions) {
-            const mcSystemMsg = 'Voc├¬ ├® um especialista em an├ílise de quest├Áes de m├║ltipla escolha. Seja conservador: quando faltar evid├¬ncia clara, responda INCONCLUSIVO em vez de chutar.';
+            const mcSystemMsg = 'Voc├â┬¬ ├â┬® um especialista em an├â┬ílise de quest├â┬Áes de m├â┬║ltipla escolha. Seja conservador: quando faltar evid├â┬¬ncia clara, responda INCONCLUSIVO em vez de chutar.';
             const mcLetterPattern = /(?:Letra|Letter)\s*([A-E])[:\s\)]/i;
             const geminiPrimary = await this._isGeminiPrimary();
 
             /** Parse MC attempts into votes using the existing parseAttemptDecision logic */
             const tabulateGroqAttempts = (attempts) => {
-                const asksIncorrect = /\b(incorreta|falsa|exceto|nao\s+e|n├úo\s+├®|errada)\b/i.test(questionText);
+                const asksIncorrect = /\b(incorreta|falsa|exceto|nao\s+e|n├â┬úo\s+├â┬®|errada)\b/i.test(questionText);
                 const votes = {};
                 const fullResponses = {};
                 let validVoteCount = 0;
@@ -2724,14 +2762,14 @@ REGRAS:
                 const secondCount = sorted[1]?.[1] || 0;
                 const hasRobustConsensus = winnerCount >= 2 && winnerCount > secondCount && (winnerCount / validVoteCount) >= 0.6;
                 if (hasRobustConsensus) {
-                    console.log(`AnswerHunter: MC consensus ÔåÆ Letter ${winnerLetter} (${winnerCount}/${validVoteCount})`);
+                    console.log(`AnswerHunter: MC consensus ├»┬┐┬¢  Letter ${winnerLetter} (${winnerCount}/${validVoteCount})`);
                     return fullResponses[winnerLetter];
                 }
                 return null; // no robust consensus
             };
 
             if (geminiPrimary) {
-                // ÔöÇÔöÇ Gemini PRIMARY for MC ÔöÇÔöÇ
+                // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Gemini PRIMARY for MC ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
                 console.log('AnswerHunter: MC via Gemini (primary)...');
                 const gResult = await this._geminiConsensus(mcSystemMsg, prompt, mcLetterPattern, { smart: true });
                 if (gResult.response) {
@@ -2739,7 +2777,7 @@ REGRAS:
                     return gResult.response;
                 }
                 // Fallback to Groq
-                console.log('AnswerHunter: Gemini MC failed ÔÇö trying Groq fallback...');
+                console.log('AnswerHunter: Gemini MC failed ├»┬┐┬¢ trying Groq fallback...');
                 const groqResult = await this._groqConsensus(mcSystemMsg, prompt, mcLetterPattern, {
                     model: groqModelSmart, temps: [0.12, 0.20, 0.28]
                 });
@@ -2747,10 +2785,10 @@ REGRAS:
                     const tabulated = tabulateGroqAttempts(groqResult.attempts);
                     if (tabulated) return tabulated;
                 }
-                return 'INCONCLUSIVO: sem consenso confi├ível entre tentativas da IA.';
+                return 'INCONCLUSIVO: sem consenso confi├â┬ível entre tentativas da IA.';
             }
 
-            // ÔöÇÔöÇ Groq PRIMARY for MC ÔöÇÔöÇ
+            // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ Groq PRIMARY for MC ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
             const groqResult = await this._groqConsensus(mcSystemMsg, prompt, mcLetterPattern, {
                 model: groqModelSmart, temps: [0.12, 0.20, 0.28]
             });
@@ -2758,19 +2796,19 @@ REGRAS:
                 const tabulated = tabulateGroqAttempts(groqResult.attempts);
                 if (tabulated) return tabulated;
             }
-            // Groq failed ÔåÆ Gemini fallback
-            console.log('AnswerHunter: Groq MC failed ÔÇö trying Gemini fallback...');
+            // Groq failed ├»┬┐┬¢  Gemini fallback
+            console.log('AnswerHunter: Groq MC failed ├»┬┐┬¢ trying Gemini fallback...');
             const gResult = await this._geminiConsensus(mcSystemMsg, prompt, mcLetterPattern, { smart: true });
             if (gResult.response) {
                 console.log('AnswerHunter: Gemini MC fallback votes:', gResult.votes);
                 return gResult.response;
             }
-            return 'INCONCLUSIVO: sem evid├¬ncia suficiente para marcar alternativa.';
+            return 'INCONCLUSIVO: sem evid├â┬¬ncia suficiente para marcar alternativa.';
         }
 
         // For open-ended questions, single attempt with provider routing
         const geminiPrimaryOpen = await this._isGeminiPrimary();
-        const openSysMsg = 'Voc├¬ ├® um assistente que responde quest├Áes com objetividade.';
+        const openSysMsg = 'Voc├â┬¬ ├â┬® um assistente que responde quest├â┬Áes com objetividade.';
 
         if (geminiPrimaryOpen) {
             // Gemini first for open-ended
@@ -2825,10 +2863,10 @@ REGRAS:
         const settings = await this._getSettings();
         const { groqApiUrl, groqApiKey, groqModelFast } = settings;
 
-        const systemMsg = 'Voc├¬ ├® um dicion├írio educacional conciso. Defina termos de forma clara e breve (2-3 linhas).';
+        const systemMsg = 'Voc├â┬¬ ├â┬® um dicion├â┬írio educacional conciso. Defina termos de forma clara e breve (2-3 linhas).';
         const prompt = contextText
-            ? `Defina o termo "${term}" considerando o seguinte contexto educacional:\n\n${contextText.slice(0, 500)}\n\nDefini├º├úo breve:`
-            : `Defina o termo "${term}" de forma breve e educacional. Defini├º├úo:`;
+            ? `Defina o termo "${term}" considerando o seguinte contexto educacional:\n\n${contextText.slice(0, 500)}\n\nDefini├â┬º├â┬úo breve:`
+            : `Defina o termo "${term}" de forma breve e educacional. Defini├â┬º├â┬úo:`;
 
         const tryGemini = async () => {
             if (!settings.geminiApiKey) return null;
@@ -2866,7 +2904,7 @@ REGRAS:
         const geminiPrimary = await this._isGeminiPrimary();
         let result = geminiPrimary ? await tryGemini() : await tryGroq();
         if (!result) result = geminiPrimary ? await tryGroq() : await tryGemini();
-        return result || `Termo n├úo encontrado: ${term}`;
+        return result || `Termo n├â┬úo encontrado: ${term}`;
     },
 
     /**
@@ -2876,22 +2914,22 @@ REGRAS:
         const settings = await this._getSettings();
         const { groqApiUrl, groqApiKey, groqModelSmart } = settings;
 
-        const systemMsg = 'Voc├¬ ├® um tutor educacional especializado. Explique conceitos de forma did├ítica, passo a passo.';
-        const prompt = `Explique de forma did├ítica e passo a passo por que a resposta correta para a quest├úo abaixo ├® a alternativa indicada.
+        const systemMsg = 'Voc├â┬¬ ├â┬® um tutor educacional especializado. Explique conceitos de forma did├â┬ítica, passo a passo.';
+        const prompt = `Explique de forma did├â┬ítica e passo a passo por que a resposta correta para a quest├â┬úo abaixo ├â┬® a alternativa indicada.
 
-QUEST├âO:
+QUEST├âÔÇÖO:
 ${question.slice(0, 1500)}
 
 RESPOSTA CORRETA:
 ${answer.slice(0, 500)}
 
 ${context ? `CONTEXTO ADICIONAL:\n${context.slice(0, 300)}\n` : ''}
-INSTRU├ç├òES:
-- Use linguagem clara e acess├¡vel para estudantes
-- Explique o racioc├¡nio por tr├ís da resposta
-- Mencione por que as outras alternativas est├úo incorretas se poss├¡vel
-- Use marcadores e par├ígrafos para facilitar a leitura
-- Seja objetivo (m├íximo 300 palavras)`;
+INSTRU├»┬┐┬¢!├»┬┐┬¢"ES:
+- Use linguagem clara e acess├â┬¡vel para estudantes
+- Explique o racioc├â┬¡nio por tr├â┬ís da resposta
+- Mencione por que as outras alternativas est├â┬úo incorretas se poss├â┬¡vel
+- Use marcadores e par├â┬ígrafos para facilitar a leitura
+- Seja objetivo (m├â┬íximo 300 palavras)`;
 
         const tryGemini = async () => {
             if (!settings.geminiApiKey) return null;
@@ -2929,7 +2967,7 @@ INSTRU├ç├òES:
         const geminiPrimary = await this._isGeminiPrimary();
         let result = geminiPrimary ? await tryGemini() : await tryGroq();
         if (!result) result = geminiPrimary ? await tryGroq() : await tryGemini();
-        return result || 'N├úo foi poss├¡vel gerar a explica├º├úo. Tente novamente.';
+        return result || 'N├â┬úo foi poss├â┬¡vel gerar a explica├â┬º├â┬úo. Tente novamente.';
     },
 
     /**
@@ -2940,15 +2978,15 @@ INSTRU├ç├òES:
         const settings = await this._getSettings();
         const { groqApiUrl, groqApiKey, groqModelSmart } = settings;
 
-        const systemMsg = 'Voc├¬ cria quest├Áes de m├║ltipla escolha educacionais. Responda APENAS em JSON v├ílido, sem texto adicional.';
-        const prompt = `Com base na quest├úo abaixo, crie UMA quest├úo similar de m├║ltipla escolha com 4 alternativas (A, B, C, D).
+        const systemMsg = 'Voc├â┬¬ cria quest├â┬Áes de m├â┬║ltipla escolha educacionais. Responda APENAS em JSON v├â┬ílido, sem texto adicional.';
+        const prompt = `Com base na quest├â┬úo abaixo, crie UMA quest├â┬úo similar de m├â┬║ltipla escolha com 4 alternativas (A, B, C, D).
 
-QUEST├âO ORIGINAL:
+QUEST├âÔÇÖO ORIGINAL:
 ${originalQuestion.slice(0, 1000)}
 
 FORMATO DE RESPOSTA (JSON exato, sem markdown):
 {
-  "questionText": "enunciado da nova quest├úo",
+  "questionText": "enunciado da nova quest├â┬úo",
   "optionsMap": {
     "A": "texto da alternativa A",
     "B": "texto da alternativa B",
@@ -2959,10 +2997,10 @@ FORMATO DE RESPOSTA (JSON exato, sem markdown):
 }
 
 REGRAS:
-- A quest├úo deve testar o mesmo conceito, mas com abordagem diferente
+- A quest├â┬úo deve testar o mesmo conceito, mas com abordagem diferente
 - Apenas UMA alternativa deve ser correta
-- As alternativas incorretas devem ser plaus├¡veis
-- Responda APENAS com o JSON, sem explica├º├Áes adicionais`;
+- As alternativas incorretas devem ser plaus├â┬¡veis
+- Responda APENAS com o JSON, sem explica├â┬º├â┬Áes adicionais`;
 
         const parseResponse = (content) => {
             if (!content) return null;
@@ -3013,7 +3051,7 @@ REGRAS:
         const geminiPrimary = await this._isGeminiPrimary();
         let result = geminiPrimary ? await tryGemini() : await tryGroq();
         if (!result) result = geminiPrimary ? await tryGroq() : await tryGemini();
-        if (!result) throw new Error('N├úo foi poss├¡vel gerar uma quest├úo similar.');
+        if (!result) throw new Error('N├â┬úo foi poss├â┬¡vel gerar uma quest├â┬úo similar.');
         return result;
     },
 
@@ -3024,12 +3062,12 @@ REGRAS:
         const settings = await this._getSettings();
         const { groqApiUrl, groqApiKey, groqModelSmart } = settings;
 
-        const systemMsg = `Voc├¬ ├® um tutor educacional. O estudante acabou de resolver uma quest├úo e tem d├║vidas.
-Quest├úo original: ${originalQuestion.slice(0, 800)}
+        const systemMsg = `Voc├â┬¬ ├â┬® um tutor educacional. O estudante acabou de resolver uma quest├â┬úo e tem d├â┬║vidas.
+Quest├â┬úo original: ${originalQuestion.slice(0, 800)}
 Resposta correta: ${originalAnswer.slice(0, 300)}
 ${context ? `Contexto: ${context.slice(0, 200)}` : ''}
 
-Responda de forma clara, did├ítica e concisa (m├íximo 200 palavras). N├úo repita a quest├úo inteira.`;
+Responda de forma clara, did├â┬ítica e concisa (m├â┬íximo 200 palavras). N├â┬úo repita a quest├â┬úo inteira.`;
 
         // Build message history for multi-turn context (cap at last 6 messages)
         const recentHistory = messageHistory.slice(-6);
@@ -3076,7 +3114,7 @@ Responda de forma clara, did├ítica e concisa (m├íximo 200 palavras). N├úo repita
         const geminiPrimary = await this._isGeminiPrimary();
         let result = geminiPrimary ? await tryGemini() : await tryGroq();
         if (!result) result = geminiPrimary ? await tryGroq() : await tryGemini();
-        return result || 'N├úo foi poss├¡vel processar sua pergunta. Tente novamente.';
+        return result || 'N├â┬úo foi poss├â┬¡vel processar sua pergunta. Tente novamente.';
     },
 
 };
diff --git a/src/services/ExtractionService.js b/src/services/ExtractionService.js
index 301ba24..7d6d1cb 100644
--- a/src/services/ExtractionService.js
+++ b/src/services/ExtractionService.js
@@ -320,9 +320,9 @@ export const ExtractionService = {
         // 2) Use anchor points in viewport (more precise)
         const probeX = Math.floor(window.innerWidth * 0.5);
         const probeYs = [
+            Math.floor(window.innerHeight * 0.15),
             Math.floor(window.innerHeight * 0.3),
-            Math.floor(window.innerHeight * 0.5),
-            Math.floor(window.innerHeight * 0.7)
+            Math.floor(window.innerHeight * 0.5)
         ];
         const hitCount = new Map();
 
@@ -367,17 +367,19 @@ export const ExtractionService = {
             const visibleBottom = Math.min(window.innerHeight, rect.bottom);
             const visibleHeight = Math.max(0, visibleBottom - visibleTop);
             const visibilityRatio = rect.height > 0 ? (visibleHeight / rect.height) : 0;
-            const sectionCenter = rect.top + rect.height / 2;
-            const distanceFromCenter = Math.abs(sectionCenter - viewportCenter);
-            const isCentered = distanceFromCenter <= window.innerHeight * 0.25;
             const isMostlyVisible = visibilityRatio >= 0.6;
+
+            // Prioritize elements near the top of the viewport instead of the absolute center
+            const distanceFromTop = Math.abs(rect.top);
+            const isNearTop = distanceFromTop <= window.innerHeight * 0.3;
+
             const score =
                 (built.optionCount * 10) +
                 (built.questionLength > 30 ? 5 : 0) +
                 (visibleHeight * 0.6) +
                 (visibilityRatio * 120) -
-                (distanceFromCenter * 0.2) +
-                (isCentered ? 40 : 0) +
+                (distanceFromTop * 0.1) +
+                (isNearTop ? 50 : 0) +
                 (isMostlyVisible ? 30 : 0);
 
             scoredCandidates.push({ text: built.text, score, rect, visibleHeight });
@@ -678,8 +680,8 @@ export const ExtractionService = {
 
         if (reviewButtons.length > 0) {
             reviewButtons.sort((a, b) => {
-                const topA = Math.abs(a.getBoundingClientRect().top - window.innerHeight / 2);
-                const topB = Math.abs(b.getBoundingClientRect().top - window.innerHeight / 2);
+                const topA = Math.abs(a.getBoundingClientRect().top - window.innerHeight * 0.2);
+                const topB = Math.abs(b.getBoundingClientRect().top - window.innerHeight * 0.2);
                 return topA - topB;
             });
             targetSection = reviewButtons[0].closest('[data-section="section_cms-atividade"]');
diff --git a/src/services/SearchService.js b/src/services/SearchService.js
index f9020c4..d1c6e21 100644
--- a/src/services/SearchService.js
+++ b/src/services/SearchService.js
@@ -1,4 +1,4 @@
-import { ApiService } from './ApiService.js';
+´╗┐import { ApiService } from './ApiService.js';
 
 // SearchService
 // Coordinates (1) direct extraction and (2) web search + evidence-based refinement.
@@ -11,9 +11,9 @@ export const SearchService = {
     _stripOptionTailNoise(text) {
         if (!text) return '';
         let cleaned = String(text).replace(/\s+/g, ' ').trim();
-        const noiseMarker = /\b(?:gabarito(?:\s+comentado)?|resposta\s+correta|resposta\s+incorreta|alternativa\s+correta|alternativa\s+incorreta|parab[e├âãÆ├é┬®]ns|voc[e├âãÆ├é┬¬]\s+acertou|confira\s+o\s+gabarito|explica[c├âãÆ├é┬º][a├âãÆ├é┬ú]o)\b/i;
+        const noiseMarker = /\b(?:gabarito(?:\s+comentado)?|resposta\s+correta|resposta\s+incorreta|alternativa\s+correta|alternativa\s+incorreta|parab[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®]ns|voc[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬¬]\s+acertou|confira\s+o\s+gabarito|explica[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o)\b/i;
         const idx = cleaned.search(noiseMarker);
-        if (idx > 20) cleaned = cleaned.slice(0, idx).trim();
+        if (idx >= 5) cleaned = cleaned.slice(0, idx).trim();
         return cleaned.replace(/[;:,\-.\s]+$/g, '').trim();
     },
 
@@ -28,7 +28,7 @@ export const SearchService = {
 
     _looksLikeCodeOption(text) {
         const body = String(text || '');
-        return /INSERT\s+INTO|SELECT\s|UPDATE\s|DELETE\s|VALUES\s*\(|CREATE\s|\{.*:.*\}|=>|->|jsonb?/i.test(body);
+        return /INSERT\s+INTO|SELECT\s|UPDATE\s|DELETE\s|VALUES\s*\(|CREATE\s|\{.*\}|=>|->|jsonb?|\bdb\.|[A-Za-z_]+\.[A-Za-z_]+\(|\[.*\]/i.test(body);
     },
 
     _normalizeCodeAwareOption(text) {
@@ -56,7 +56,7 @@ export const SearchService = {
 
     _isUsableOptionBody(body) {
         const cleaned = String(body || '').replace(/\s+/g, ' ').trim();
-        if (!cleaned || cleaned.length < 8) return false;
+        if (!cleaned || cleaned.length < 2) return false;
         if (/^[A-E]\s*[\)\.\-:]?\s*$/i.test(cleaned)) return false;
         if (/^(?:[A-E]\s*[\)\.\-:]\s*){1,2}$/i.test(cleaned)) return false;
         if (/^(?:resposta|gabarito|alternativa\s+correta)\b/i.test(cleaned)) return false;
@@ -72,7 +72,7 @@ export const SearchService = {
         const seenBodies = new Set();
         // Code-aware dedup: preserve SQL/JSON operators that plain normalization strips.
         const _codeDedupKey = (body) => this._normalizeCodeAwareOption(body).replace(/\s+/g, '');
-        const optionRe = /^["'ÔÇ£ÔÇØÔÇÿÔÇÖ\(\[]?\s*([A-E])\s*[\)\.\-:]\s*(.+)$/i;
+        const optionRe = /^["'├»┬┐┬¢S├ó┬¼┬Ø├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢"\(\[]?\s*([A-E])\s*[\)\.\-:]\s*(.+)$/i;
         for (const line of lines) {
             const m = line.match(optionRe);
             if (!m) continue;
@@ -91,7 +91,7 @@ export const SearchService = {
         }
 
         // Secondary pass (always): recover missing letters from inline/quoted patterns.
-        const inlineRe = /(?:^|[\n\r\t ;"'ÔÇ£ÔÇØÔÇÿÔÇÖ])([A-E])\s*[\)\.\-:]\s*([^]*?)(?=(?:[\n\r\t ;"'ÔÇ£ÔÇØÔÇÿÔÇÖ][A-E]\s*[\)\.\-:]\s)|$)/gi;
+        const inlineRe = /(?:^|[\n\r\t ;"'├»┬┐┬¢S├ó┬¼┬Ø├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢"])([A-E])\s*[\)\.\-:]\s*([^]*?)(?=(?:[\n\r\t ;"'├»┬┐┬¢S├ó┬¼┬Ø├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢"][A-E]\s*[\)\.\-:]\s)|$)/gi;
         let m;
         while ((m = inlineRe.exec(text)) !== null) {
             const letter = (m[1] || '').toUpperCase();
@@ -339,7 +339,7 @@ export const SearchService = {
         if (!text) return null;
 
         const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
-        const finalLineRe = /^(?:(?:resposta\s+final|conclus[a├ú]o|gabarito)\s*[:\-]\s*)?(?:letra|gabarito|resposta\s+final|alternativa\s+correta|letter|option)\s*[:\-]?\s*([A-E])\b(?:\s*[:.\-]|$)/i;
+        const finalLineRe = /^(?:(?:resposta\s+final|conclus[a├â┬ú]o|gabarito)\s*[:\-]\s*)?(?:letra|gabarito|resposta\s+final|alternativa\s+correta|letter|option)\s*[:\-]?\s*([A-E])\b(?:\s*[:.\-]|$)/i;
         for (let i = lines.length - 1; i >= Math.max(0, lines.length - 4); i -= 1) {
             const m = lines[i].match(finalLineRe);
             if (m) return (m[1] || '').toUpperCase();
@@ -352,11 +352,11 @@ export const SearchService = {
         if (uniqueTagged.length === 1) return uniqueTagged[0];
         if (uniqueTagged.length > 1) return null;
 
-        // Match "a resposta (correta) ├®/seria (a alternativa) X"
+        // Match "a resposta (correta) ├â┬®/seria (a alternativa) X"
         const prosePatterns = [
-            /(?:resposta|answer)\s+(?:correta\s+)?(?:[e├®├ë]|seria)\s+(?:a\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
-            /(?:alternativa|opcao|op[├ºc][a├ú]o)\s+(?:correta\s+)?(?:[e├®├ë]\s+)?(?:a\s+)?([A-E])\b/gi,
-            /\bcorresponde\s+(?:[a├á]\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi
+            /(?:resposta|answer)\s+(?:correta\s+)?(?:[e├â┬®├»┬┐┬¢0]|seria)\s+(?:a\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
+            /(?:alternativa|opcao|op[├â┬ºc][a├â┬ú]o)\s+(?:correta\s+)?(?:[e├â┬®├»┬┐┬¢0]\s+)?(?:a\s+)?([A-E])\b/gi,
+            /\bcorresponde\s+(?:[a├â┬á]\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi
         ];
         for (const re of prosePatterns) {
             const proseHits = [...text.matchAll(re)].map(m => (m[1] || '').toUpperCase()).filter(Boolean);
@@ -433,14 +433,14 @@ export const SearchService = {
         return bestLetter;
     },
 
-    // Ôû©Ôû©Ôû© GOOGLE AI OVERVIEW / ANSWER BOX EXTRACTION Ôû©Ôû©Ôû©
+    // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ GOOGLE AI OVERVIEW / ANSWER BOX EXTRACTION ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
     // Extracts an answer letter from Serper meta signals (answerBox, aiOverview,
     // peopleAlsoAsk) that come "for free" with the search results.
     _extractLetterFromGoogleMeta(serperMeta, questionStem, originalOptionsMap, originalOptions) {
         if (!serperMeta) return null;
         const results = []; // {letter, confidence, method, evidence}
 
-        // ÔöÇÔöÇ 1) answerBox ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ 1) answerBox ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         const ab = serperMeta.answerBox;
         if (ab) {
             const abText = [ab.title, ab.snippet, ab.answer, ab.highlighted_words?.join(' ')]
@@ -453,7 +453,7 @@ export const SearchService = {
             }
         }
 
-        // ÔöÇÔöÇ 2) aiOverview (Serper may return embedded or via separate key) ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ 2) aiOverview (Serper may return embedded or via separate key) ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         const aio = serperMeta.aiOverview;
         if (aio) {
             let aioText = '';
@@ -474,7 +474,7 @@ export const SearchService = {
             }
         }
 
-        // ÔöÇÔöÇ 3) peopleAlsoAsk ÔöÇÔöÇ
+        // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ 3) peopleAlsoAsk ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
         const paa = serperMeta.peopleAlsoAsk;
         if (Array.isArray(paa) && paa.length > 0) {
             // Only use PAA entries whose question is similar to the user's question
@@ -489,7 +489,7 @@ export const SearchService = {
                 if (qSim < 0.40) continue;
                 const parsed = this._parseGoogleMetaText(paaSnippet, originalOptionsMap, originalOptions);
                 if (parsed) {
-                    // PAA is less reliable ÔÇö reduce confidence
+                    // PAA is less reliable ├»┬┐┬¢ reduce confidence
                     results.push({
                         ...parsed,
                         confidence: Math.min(parsed.confidence, 0.72),
@@ -530,17 +530,17 @@ export const SearchService = {
     },
 
     // Core parser: extracts answer letter from Google meta text by:
-    // 1. Explicit "alternativa correta ├® a C" / "Letra C" patterns
+    // 1. Explicit "alternativa correta ├â┬® a C" / "Letra C" patterns
     // 2. Content match against user's option bodies
     _parseGoogleMetaText(text, originalOptionsMap, originalOptions) {
         if (!text || text.length < 15) return null;
 
         // Strategy 1: Explicit letter mention
         const explicitPatterns = [
-            /(?:alternativa|resposta|gabarito|letra|op[├ºc][a├ú]o)\s+(?:correta\s+)?(?:[e├®├ë]\s+)?(?:a\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
-            /\b([A-E])\s*[\)\.\-:]\s*(?:[Nn][a├ú]o\s+exige|[Ee]xige|[Pp]ermite|[Rr]equere?|[Dd]efine|[Rr]epresenta)/gi,
-            /\bcorresponde\s+(?:[a├á]\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
-            /(?:alternativa\s+correta\s+(?:[e├®├ë]|seria)\s+(?:a\s+)?)([A-E])\b/gi
+            /(?:alternativa|resposta|gabarito|letra|op[├â┬ºc][a├â┬ú]o)\s+(?:correta\s+)?(?:[e├â┬®├»┬┐┬¢0]\s+)?(?:a\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
+            /\b([A-E])\s*[\)\.\-:]\s*(?:[Nn][a├â┬ú]o\s+exige|[Ee]xige|[Pp]ermite|[Rr]equere?|[Dd]efine|[Rr]epresenta)/gi,
+            /\bcorresponde\s+(?:[a├â┬á]\s+)?(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
+            /(?:alternativa\s+correta\s+(?:[e├â┬®├»┬┐┬¢0]|seria)\s+(?:a\s+)?)([A-E])\b/gi
         ];
         const explicitHits = [];
         for (const re of explicitPatterns) {
@@ -558,10 +558,10 @@ export const SearchService = {
             }
         }
 
-        // Strategy 2: Check for "Ô£à" or bold marker followed by letter
+        // Strategy 2: Check for "├»┬┐┬¢S&" or bold marker followed by letter
         const checkMarkPatterns = [
-            /[Ô£àÔ£ôÔÿæ]\s*(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
-            /(?:correta|certa|right|correct)\s*[:\-ÔÇô]?\s*(?:alternativa\s+|letra\s+)?([A-E])\b/gi
+            /[├»┬┐┬¢S&├»┬┐┬¢S├»┬┐┬¢├»┬┐┬¢]\s*(?:alternativa\s+|letra\s+)?([A-E])\b/gi,
+            /(?:correta|certa|right|correct)\s*[:\-├»┬┐┬¢]?\s*(?:alternativa\s+|letra\s+)?([A-E])\b/gi
         ];
         for (const re of checkMarkPatterns) {
             const matches = [...text.matchAll(re)].map(m => (m[1] || '').toUpperCase()).filter(l => /^[A-E]$/.test(l));
@@ -571,7 +571,7 @@ export const SearchService = {
             }
         }
 
-        // Strategy 3: Content-match ÔÇö find which user option body is best contained in the text
+        // Strategy 3: Content-match ├»┬┐┬¢ find which user option body is best contained in the text
         if (originalOptionsMap && Object.keys(originalOptionsMap).length >= 2) {
             const normText = this._normalizeOption(text);
             let bestLetter = null;
@@ -610,7 +610,7 @@ export const SearchService = {
             }
         }
 
-        // Strategy 4: Fallback ÔÇö try _parseAnswerLetter on the raw text
+        // Strategy 4: Fallback ├»┬┐┬¢ try _parseAnswerLetter on the raw text
         const parsedLetter = this._parseAnswerLetter(text);
         if (parsedLetter && originalOptionsMap?.[parsedLetter]) {
             return { letter: parsedLetter, confidence: 0.70 };
@@ -653,7 +653,7 @@ export const SearchService = {
         return map;
     },
 
-    // Ôû©Ôû©Ôû© LETTER REMAPPING FOR SHUFFLED OPTIONS Ôû©Ôû©Ôû©
+    // ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢ LETTER REMAPPING FOR SHUFFLED OPTIONS ├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢├»┬┐┬¢
     // Smart-join PDF fragment texts: detects mid-word breaks (caused by
     // <span class="blank"> spacers) and joins WITHOUT a space when the
     // previous fragment ends with a letter and the next starts lowercase.
@@ -675,8 +675,8 @@ export const SearchService = {
 
     // Content-based verification: after remapping, verify the highlighted text
     // actually matches the user's option at the resulting letter.
-    // Returns { confidence, letter } ÔÇö if the highlighted text doesn't match ANY
-    // user option, returns null (reject the signal ÔÇö wrong question anchored).
+    // Returns { confidence, letter } ├»┬┐┬¢ if the highlighted text doesn't match ANY
+    // user option, returns null (reject the signal ├»┬┐┬¢ wrong question anchored).
     // If it matches a DIFFERENT user option than remappedLetter, returns the correct one.
     _verifyHighlightMatch(rawLetter, remappedLetter, sourceOptionsMap, userOptionsMap, baseConfidence) {
         const highlightedText = (sourceOptionsMap || {})[rawLetter] || '';
@@ -712,15 +712,15 @@ export const SearchService = {
         // Case 1: highlighted text matches a user option well
         if (bestMatchLetter && bestMatchScore >= 0.55) {
             if (bestMatchLetter !== remappedLetter) {
-                console.log(`    [verify] Ô£à CONTENT OVERRIDE: remapped was ${remappedLetter} but highlighted text matches user ${bestMatchLetter} (score=${bestMatchScore >= 1000 ? 'contains' : bestMatchScore.toFixed(3)})`);
+                console.log(`    [verify] ├»┬┐┬¢S& CONTENT OVERRIDE: remapped was ${remappedLetter} but highlighted text matches user ${bestMatchLetter} (score=${bestMatchScore >= 1000 ? 'contains' : bestMatchScore.toFixed(3)})`);
             } else {
-                console.log(`    [verify] Ô£à CONFIRMED: highlighted text matches user ${bestMatchLetter} (score=${bestMatchScore >= 1000 ? 'contains' : bestMatchScore.toFixed(3)})`);
+                console.log(`    [verify] ├»┬┐┬¢S& CONFIRMED: highlighted text matches user ${bestMatchLetter} (score=${bestMatchScore >= 1000 ? 'contains' : bestMatchScore.toFixed(3)})`);
             }
             return { confidence: baseConfidence, letter: bestMatchLetter };
         }
 
-        // Case 2: highlighted text doesn't match ANY user option ÔåÆ wrong question
-        console.log(`    [verify] ÔØî REJECTED: highlighted text matches NO user option (bestScore=${bestMatchScore.toFixed(3)} best=${bestMatchLetter}). Anchor likely on wrong question.`);
+        // Case 2: highlighted text doesn't match ANY user option ├»┬┐┬¢  wrong question
+        console.log(`    [verify] ├»┬┐┬¢R REJECTED: highlighted text matches NO user option (bestScore=${bestMatchScore.toFixed(3)} best=${bestMatchLetter}). Anchor likely on wrong question.`);
         return null;
     },
 
@@ -753,8 +753,8 @@ export const SearchService = {
         // Stripping ALL spaces makes the comparison immune to these artifacts.
         const skeletonSource = normSource.replace(/\s+/g, '');
         // Always search ALL user options to find the best text match.
-        // No early-exit alignment check ÔÇö options like "Exige a defini├º├úo..."
-        // and "N├úo exige a predefini├º├úo..." have high Dice (~0.93) but are
+        // No early-exit alignment check ├»┬┐┬¢ options like "Exige a defini├â┬º├â┬úo..."
+        // and "N├â┬úo exige a predefini├â┬º├â┬úo..." have high Dice (~0.93) but are
         // completely different options.  The full search reliably picks the
         // correct match because the TRUE match has Dice 1.0 or containment.
         let bestLetter = null;
@@ -849,7 +849,7 @@ export const SearchService = {
         return hits;
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É DICE SIMILARITY (bigram) ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É DICE SIMILARITY (bigram) ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     // Character-bigram Dice coefficient: 0..1
     _diceSimilarity(a, b) {
         if (!a || !b) return 0;
@@ -871,9 +871,9 @@ export const SearchService = {
         return (2 * intersection) / (a.length - 1 + b.length - 1) || 0;
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É QUESTION SIMILARITY SCORE ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É QUESTION SIMILARITY SCORE ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     // Returns 0..1 score indicating how similar a source snippet is to the original question stem.
-    // Used to gate Brainly and other weak sources ├â┬ó├óÔÇÜ┬¼├óÔé¼┬Ø they must match the actual question.
+    // Used to gate Brainly and other weak sources ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢a├é┬¼├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬Ø they must match the actual question.
     _questionSimilarityScore(sourceText, questionStem) {
         if (!sourceText || !questionStem) return 0;
         const srcNorm = this._normalizeOption(sourceText);
@@ -902,7 +902,7 @@ export const SearchService = {
         return Math.min(1.0, tokenScore * 0.5 + prefixMatch + diceScore * 0.3);
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É CANONICAL QUESTION HASH ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É CANONICAL QUESTION HASH ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     // Creates a stable hash from question + options for cache/dedup
     _canonicalizeQuestion(questionText) {
         const stem = this._extractQuestionStem(questionText);
@@ -1200,7 +1200,7 @@ export const SearchService = {
         }
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É POLARITY DETECTION ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É POLARITY DETECTION ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     _detectQuestionPolarity(questionText) {
         if (!questionText) return 'CORRECT';
         const stemOnly = this._extractQuestionStem(questionText);
@@ -1208,15 +1208,23 @@ export const SearchService = {
         const incorrectPatterns = [
             /alternativa\s+incorreta/i,
             /afirmativa\s+incorreta/i,
+            /afirmativa\s+errada/i,
             /opcao\s+incorreta/i,
             /alternativa\s+errada/i,
             /alternativa\s+falsa/i,
+            /opcao\s+falsa/i,
             /nao\s+(?:e|esta)\s+corret[ao]/i,
             /assinale\s+a\s+incorreta/i,
             /marque\s+a\s+incorreta/i,
             /assinale\s+a\s+errada/i,
             /assinale\s+a\s+falsa/i,
-            /\bexceto\b/i
+            /\bexceto\b/i,
+            /\bnao\b.*\busad[ao]\b/i,
+            /\bque\s+nao\s+e\b/i,
+            /\bindica\b.*\bnao\b/i,
+            /\bnao\b.*\bpertence\b/i,
+            /\bnao\b.*\bcorresponde\b/i,
+            /\brelacao\s+incorreta\b/i
         ];
         for (const re of incorrectPatterns) {
             if (re.test(text)) return 'INCORRECT';
@@ -1226,41 +1234,72 @@ export const SearchService = {
 
 
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É FINGERPRINT-BASED QUESTION BLOCK FINDING ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
-    _findQuestionBlockByFingerprint(sourceText, questionText) {
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É FINGERPRINT-BASED QUESTION BLOCK FINDING ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
+    _findQuestionBlockByFingerprint(sourceText, questionText, originalOptions) {
         if (!sourceText || !questionText) return null;
         const stem = this._extractQuestionStem(questionText);
         const tokens = this._extractKeyTokens(stem);
         if (tokens.length < 3) return null;
 
         const lines = sourceText.split('\n');
-        let bestStart = -1;
-        let bestHits = 0;
+        // Collect ALL candidate anchors (not just best) to disambiguate similar questions
+        const candidates = [];
         const windowSize = 15;
         for (let i = 0; i < lines.length - 3; i++) {
             const windowText = lines.slice(i, Math.min(lines.length, i + windowSize)).join('\n');
             const hits = this._countTokenHits(windowText, tokens);
-            if (hits > bestHits) {
-                bestHits = hits;
-                bestStart = i;
+            if (hits >= Math.max(3, Math.floor(tokens.length * 0.5))) {
+                candidates.push({ start: i, hits, windowText });
             }
         }
-        const threshold = Math.max(3, Math.floor(tokens.length * 0.5));
-        if (bestStart < 0 || bestHits < threshold) return null;
-        const blockStart = Math.max(0, bestStart - 2);
-        const blockEnd = Math.min(lines.length, bestStart + 40);
+
+        if (candidates.length === 0) return null;
+
+        // If multiple candidates with close hit counts, use options matching as tiebreaker
+        if (candidates.length > 1 && originalOptions && originalOptions.length >= 2) {
+            const optBodies = originalOptions
+                .map(o => { const m = o.match(/^[A-E]\)\s*(.*)/i); return m ? this._normalizeOption(m[1]) : ''; })
+                .filter(b => b.length >= 3);
+
+            for (const cand of candidates) {
+                const blockStart = Math.max(0, cand.start - 2);
+                const blockEnd = Math.min(lines.length, cand.start + 120);
+                const blockText = this._normalizeOption(lines.slice(blockStart, blockEnd).join('\n'));
+                let optHits = 0;
+                for (const body of optBodies) {
+                    if (blockText.includes(body)) optHits++;
+                }
+                cand.optHits = optHits;
+            }
+            // Sort by: options matched (desc), then token hits (desc)
+            candidates.sort((a, b) => (b.optHits - a.optHits) || (b.hits - a.hits));
+            console.log(`    [fingerprint] ${candidates.length} candidates, best: hits=${candidates[0].hits} optHits=${candidates[0].optHits}`);
+        } else {
+            candidates.sort((a, b) => b.hits - a.hits);
+        }
+
+        const best = candidates[0];
+        const blockStart = Math.max(0, best.start - 2);
+        const blockEnd = Math.min(lines.length, best.start + 120); // allow up to 120 lines to ensure options + gabarito are captured
         return lines.slice(blockStart, blockEnd).join('\n');
     },
 
-    _findQuestionBlock(sourceText, questionText) {
+    _findQuestionBlock(sourceText, questionText, originalOptions) {
         if (!sourceText || !questionText) return null;
-        // Attempt 1: by question number
+
+        // Attempt 1: fingerprint (most reliable for exact position on multi-question pages)
+        const fpBlock = this._findQuestionBlockByFingerprint(sourceText, questionText, originalOptions);
+        if (fpBlock) {
+            return { text: fpBlock, method: 'fingerprint' };
+        }
+
+        // Attempt 2: by question number (fallback)
         const qNumMatch = (questionText || '').match(/^\s*(\d{1,3})\s*[\)\.\:\-]/);
         if (qNumMatch) {
             const qNum = qNumMatch[1];
             const patterns = [
                 new RegExp(`(?:^|\\n)\\s*${qNum}\\s*[\\)\\.\\:\\-]`, 'm'),
-                new RegExp(`(?:^|\\n)\\s*(?:Quest[a├âãÆ├é┬ú]o|Questao)\\s+${qNum}\\b`, 'im')
+                new RegExp(`(?:^|\\n)\\s*(?:Quest[a├â┬ú]o|Questao)\\s+${qNum}\\b`, 'im')
             ];
             for (const re of patterns) {
                 const match = re.exec(sourceText);
@@ -1271,25 +1310,21 @@ export const SearchService = {
                 }
             }
         }
-        // Attempt 2: fingerprint
-        const fpBlock = this._findQuestionBlockByFingerprint(sourceText, questionText);
-        if (fpBlock) {
-            return { text: fpBlock, method: 'fingerprint' };
-        }
+
         return null;
     },
 
-    _buildQuestionScopedText(sourceText, questionText, maxChars = 3200) {
+    _buildQuestionScopedText(sourceText, questionText, maxChars = 3200, originalOptions) {
         const raw = String(sourceText || '').trim();
         if (!raw) return '';
-        const block = this._findQuestionBlock(raw, questionText);
+        const block = this._findQuestionBlock(raw, questionText, originalOptions);
         if (block?.text && block.text.length >= 120) {
             return block.text.slice(0, maxChars);
         }
         return raw.slice(0, maxChars);
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É RANKED CANDIDATE SELECTION ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É RANKED CANDIDATE SELECTION ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     _chooseBestCandidate(candidates) {
         if (!candidates || candidates.length === 0) return null;
         if (candidates.length === 1) return candidates[0];
@@ -1311,7 +1346,7 @@ export const SearchService = {
         return best;
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É ENHANCED EXPLICIT GABARITO EXTRACTION (polarity-aware) ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É ENHANCED EXPLICIT GABARITO EXTRACTION (polarity-aware) ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     _extractExplicitGabarito(text, questionText = '') {
         if (!text) return null;
         const questionPolarity = this._detectQuestionPolarity(questionText);
@@ -1335,16 +1370,68 @@ export const SearchService = {
         return this._chooseBestCandidate(matches);
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É LOCAL ANSWER EXTRACTION ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // --- LOCAL HALLUCINATION GUARD ---
+    _isExplicitLetterSafe(text, letter, expectedBody) {
+        if (!expectedBody) return true; // nothing to guard against
+
+        const isShortAcronym = expectedBody.length <= 6 && this._looksLikeCodeOption(expectedBody);
+
+        // 1) If the text is an explanation and the user's short acronym is completely absent = cross-question
+        if (isShortAcronym && text.length > 80) {
+            if (!this._normalizeCodeAwareOption(text).includes(this._normalizeCodeAwareOption(expectedBody))) {
+                console.log(`    [guard] REJECT: Explicit said ${letter} but short option "${expectedBody}" is absent.`);
+                return false;
+            }
+        }
+
+        // 2) Parse the immediate literal option text written after the letter (e.g. "letra d) csv")
+        const rx = new RegExp(`(?:letra|alternativa|op[c├â┬º][a├â┬ú]o|resposta)\\s*(?:correta\\s*(?:[e├â┬®]\\s*(?:a\\s+)?)?)?${letter}\\s*[)\\.\\-:]?\\s*([^\\.,;\\n]+)`, 'i');
+        const m = text.match(rx);
+        if (m && m[1]) {
+            const nextWords = this._normalizeOption(m[1].trim());
+            // Drop explanation fillers
+            if (nextWords && !/^(?:pois|porque|j[a├â┬í]\\s*que|dado|como|sendo|visto|uma\\s*vez)/.test(nextWords)) {
+                const dice = this._diceSimilarity(nextWords, expectedBody);
+                if (dice < 0.2) {
+                    const nextTokens = nextWords.split(/\\s+/).filter(t => t.length >= 3);
+                    let shared = 0;
+                    for (const tk of nextTokens) { if (expectedBody.includes(tk)) shared++; }
+
+                    // Clashes with the actual noun/content?
+                    if (shared === 0 && nextTokens.length >= 1 && nextTokens.length <= 4) {
+                        console.log(`    [guard] REJECT: Explicit text "${nextWords}" contradicts expected "${expectedBody}".`);
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
+    },
+
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É LOCAL ANSWER EXTRACTION ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     _extractAnswerLocally(sourceText, questionText, originalOptions) {
         if (!sourceText || sourceText.length < 50) return null;
-        const block = this._findQuestionBlock(sourceText, questionText);
+        const block = this._findQuestionBlock(sourceText, questionText, originalOptions);
         const searchText = block ? block.text : sourceText;
+
+        const optionsMap = {};
+        if (originalOptions) {
+            for (const opt of originalOptions) {
+                const m = opt.match(/^([A-E])\)\s*(.*)/i);
+                if (m) optionsMap[m[1].toUpperCase()] = m[2].trim();
+            }
+        }
+
         // 1) Try explicit gabarito patterns first (uploaded answer keys, Brainly, etc.)
         const gabarito = this._extractExplicitGabarito(searchText, questionText);
         if (gabarito) {
-            return { ...gabarito, evidenceType: 'explicit-gabarito', blockMethod: block?.method || 'full-text' };
+            const expectedBody = optionsMap[gabarito.letter];
+            if (!expectedBody || this._isExplicitLetterSafe(searchText, gabarito.letter, expectedBody)) {
+                return { ...gabarito, evidenceType: 'explicit-gabarito', blockMethod: block?.method || 'full-text' };
+            }
         }
+
         // 2) Try explanation-to-option content matching
         const explanationMatch = this._matchExplanationToOption(searchText, questionText, originalOptions);
         if (explanationMatch) {
@@ -1360,8 +1447,8 @@ export const SearchService = {
      * This method extracts such explanation blocks and matches them back to the user's options
      * using keyword/concept overlap.
      *
-     * Example: "...devido ao fato de que seu suporte ao processamento n├úo segue o modelo
-     * cl├íssico de transa├º├Áes..." ÔåÆ matches option E: "Ter suporte de transa├º├Áes diferente do relacional"
+     * Example: "...devido ao fato de que seu suporte ao processamento n├â┬úo segue o modelo
+     * cl├â┬íssico de transa├â┬º├â┬Áes..." ├»┬┐┬¢  matches option E: "Ter suporte de transa├â┬º├â┬Áes diferente do relacional"
      */
     _matchExplanationToOption(sourceText, questionText, originalOptions) {
         if (!sourceText || !originalOptions || originalOptions.length < 2) return null;
@@ -1369,6 +1456,17 @@ export const SearchService = {
         const stemTokens = this._extractKeyTokens(questionStem);
         if (stemTokens.length < 2) return null;
 
+        // Detect question polarity ÔÇö negation-aware guard
+        const polarity = this._detectQuestionPolarity(questionStem);
+        // Also detect "n├úo ├® usado", "que n├úo", "n├úo pertence" patterns that _detectQuestionPolarity may miss
+        const stemNorm = (questionStem || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
+        const hasNegation = polarity === 'INCORRECT'
+            || /\bnao\b.*\busad[ao]\b/.test(stemNorm)
+            || /\bnao\b.*\bpertence\b/.test(stemNorm)
+            || /\bque\s+nao\s+[e├®]\b/.test(stemNorm)
+            || /\bindica\b.*\bnao\b/.test(stemNorm)
+            || /\bnao\b.*\bcorresponde\b/.test(stemNorm);
+
         // Build options map from originalOptions
         const optionsMap = {};
         for (const opt of originalOptions) {
@@ -1378,7 +1476,7 @@ export const SearchService = {
         if (Object.keys(optionsMap).length < 2) return null;
 
         // Find the question block in the source text
-        const block = this._findQuestionBlock(sourceText, questionText);
+        const block = this._findQuestionBlock(sourceText, questionText, originalOptions);
         const searchText = block ? block.text : sourceText;
 
         // Find the end of the options area (after the last option letter)
@@ -1397,8 +1495,21 @@ export const SearchService = {
 
         console.log(`    [expl-match] Explanation text found (${explanationText.length} chars), topicHits=${topicHits}/${stemTokens.length}`);
 
+        const optionBodiesNorm = Object.values(optionsMap).map((body) => this._normalizeOption(body));
+        const shortAcronymCount = optionBodiesNorm.filter((body) => body.length > 0 && body.length <= 8 && body.split(/\s+/).length <= 1).length;
+        const acronymCluster = shortAcronymCount >= Math.max(3, Math.ceil(optionBodiesNorm.length * 0.6));
+        const hasAnswerCue = /(gabarito|resposta\s+correta|alternativa\s+correta|letra\s*[a-e]\b)/i.test(explanationText);
+        const escRe = (s) => String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+        const countWholeWordMentions = (haystackNorm, needleNorm) => {
+            if (!haystackNorm || !needleNorm) return 0;
+            const rx = new RegExp(`\\b${escRe(needleNorm)}\\b`, 'g');
+            const matches = haystackNorm.match(rx);
+            return matches ? matches.length : 0;
+        };
+
         // For each option, compute how strongly the explanation text mentions its key concepts
         const scores = {};
+        const optionMeta = {};
         for (const [letter, body] of Object.entries(optionsMap)) {
             const optNorm = this._normalizeOption(body);
             const optTokens = optNorm.split(/\s+/).filter(t => t.length >= 3);
@@ -1413,12 +1524,38 @@ export const SearchService = {
 
             // Also compute Dice similarity between explanation and option
             const dice = this._diceSimilarity(explNorm, optNorm);
+            const exactMentions = countWholeWordMentions(explNorm, optNorm);
 
             // Combined score: token overlap ratio + Dice similarity
             scores[letter] = (tokenRatio * 0.6) + (dice * 0.4);
+            optionMeta[letter] = {
+                tokenHits,
+                tokenCount: optTokens.length,
+                exactMentions,
+                optNormLength: optNorm.length
+            };
             console.log(`    [expl-match] ${letter}) tokenHits=${tokenHits}/${optTokens.length} dice=${dice.toFixed(3)} score=${scores[letter].toFixed(3)} body="${body.slice(0, 60)}"`);
         }
 
+        // ÔöÇÔöÇ NEGATION-AWARE INVERSION ÔöÇÔöÇ
+        // When the question asks "which is NOT used / incorrect / false", the explanation
+        // typically describes what IS correct. The option that is LEAST mentioned is the
+        // answer. Invert scores so the lowest-scoring option becomes the best candidate.
+        if (hasNegation) {
+            console.log(`    [expl-match] NEGATION detected ÔÇö inverting scores (polarity=${polarity})`);
+            const allLetters = Object.keys(scores);
+            const maxScore = Math.max(...Object.values(scores));
+            // Only invert if there's meaningful differentiation (at least one option scored > 0)
+            if (maxScore > 0) {
+                for (const letter of allLetters) {
+                    scores[letter] = maxScore - scores[letter];
+                }
+                for (const [letter] of Object.entries(scores)) {
+                    console.log(`    [expl-match] ${letter}) inverted_score=${scores[letter].toFixed(3)}`);
+                }
+            }
+        }
+
         // Find best and second-best
         const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
         if (sorted.length < 2) return null;
@@ -1429,13 +1566,48 @@ export const SearchService = {
         const margin = bestScore - secondScore;
         console.log(`    [expl-match] best=${bestLetter} score=${bestScore.toFixed(3)} second=${secondScore.toFixed(3)} margin=${margin.toFixed(3)}`);
 
-        if (bestScore < 0.25 || margin < 0.08) {
-            console.log(`    [expl-match] REJECTED: score too low or margin too small`);
+        const bestMeta = optionMeta[bestLetter] || { tokenCount: 0, exactMentions: 0, optNormLength: 999 };
+        const bestIsShortAcronym = bestMeta.optNormLength <= 8 && bestMeta.tokenCount <= 1;
+        const mentionedOptionCount = Object.values(optionMeta).filter((m) => (m?.exactMentions || 0) > 0).length;
+
+        // Guard against cross-question contamination: acronym option sets (XML/JSON/BSON...)
+        // frequently appear as lists in explanations and should not decide the gabarito alone.
+        // Skip this guard when negation is active ÔÇö inverted scores already handle differentiation.
+        if (!hasNegation && acronymCluster && mentionedOptionCount >= 3 && !hasAnswerCue) {
+            console.log(`    [expl-match] REJECTED: acronym cluster with multiple option mentions and no explicit answer cue`);
+            return null;
+        }
+        if (!hasNegation && acronymCluster && bestIsShortAcronym && bestMeta.exactMentions < 2 && !hasAnswerCue) {
+            console.log(`    [expl-match] REJECTED: short acronym option with weak mention count (mentions=${bestMeta.exactMentions})`);
+            return null;
+        }
+
+        const isStrongAcronymHit = bestIsShortAcronym && bestMeta.exactMentions >= 2 && bestScore >= 0.6 && margin >= 0.2;
+        // For negation questions, use relaxed thresholds since inverted scores behave differently
+        const requiredScore = hasNegation ? 0.15 : (bestIsShortAcronym ? (isStrongAcronymHit ? 0.60 : 0.80) : 0.25);
+        const requiredMargin = hasNegation ? 0.05 : (bestIsShortAcronym ? (isStrongAcronymHit ? 0.18 : 0.30) : 0.08);
+
+        if (bestScore < requiredScore || margin < requiredMargin) {
+            console.log(`    [expl-match] REJECTED: score too low or margin too small (reqScore=${requiredScore}, reqMargin=${requiredMargin}, strongAcronym=${isStrongAcronymHit})`);
             return null;
         }
 
         // Compute confidence based on score strength and margin
-        const confidence = Math.min(0.88, 0.60 + (bestScore * 0.2) + (margin * 0.3));
+        let confidence = Math.min(0.88, 0.60 + (bestScore * 0.2) + (margin * 0.3));
+
+        // For negation-inverted results, slightly lower confidence since inversion is heuristic
+        if (hasNegation) {
+            confidence = Math.min(confidence, 0.72);
+            console.log(`    [expl-match] NEGATION confidence capped to ${confidence.toFixed(2)}`);
+        }
+
+        // Prevent generic acronyms ("XML", "JSON") organically present in huge database tutorials
+        // from being falsely categorized as the definitive "gabarito" answer without context.
+        if (!hasNegation && bestIsShortAcronym && explanationText.length > 300 && !hasAnswerCue) {
+            confidence = Math.min(confidence, 0.35);
+            console.log(`    [expl-match] PENALTY: acronym matched in long text -> capped confidence to ${confidence.toFixed(2)}`);
+        }
+
         console.log(`    [expl-match] ACCEPTED: letter=${bestLetter} confidence=${confidence.toFixed(2)}`);
 
         return {
@@ -1446,10 +1618,10 @@ export const SearchService = {
         };
     },
 
-    // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É MATCH QUALITY COMPUTATION ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+    // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É MATCH QUALITY COMPUTATION ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
     computeMatchQuality(sourceText, questionText, originalOptions, originalOptionsMap) {
         let quality = 0;
-        const block = this._findQuestionBlock(sourceText, questionText);
+        const block = this._findQuestionBlock(sourceText, questionText, originalOptions);
         if (block) quality += block.method === 'fingerprint' ? 3 : 2;
         if (originalOptions && originalOptions.length >= 2) {
             const sourceOptions = [];
@@ -1479,11 +1651,11 @@ export const SearchService = {
 
         if (polarity === 'INCORRECT' || polarity === 'UNKNOWN') {
             patterns.push(
-                /(?:^|\b)(?:op[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*(?:├âãÆ├é┬®|e)\s*(?:a\s+)?(?:letra\s*)?([A-E])\b/i,
-                /(?:^|\b)(?:a\s+)?(?:op[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|alternativa)\s+([A-E])\s*(?:├âãÆ├é┬®|e)\s*(?:a\s+)?(?:falsa|incorreta|errada)\b/i,
-                /(?:^|\b)(?:a\s+)?(?:op[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*[:\-]?\s*([A-E])\b/i,
-                // Common SERP phrasing: "A op├âãÆ├é┬º├âãÆ├é┬úo falsa ├âãÆ├é┬® a e) ..."
-                /(?:^|\b)(?:a\s+)?(?:op[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*(?:├âãÆ├é┬®|e)\s*(?:a\s+)?([A-E])\s*[\)\.\-:]/i
+                /(?:^|\b)(?:op[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*(?:├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®|e)\s*(?:a\s+)?(?:letra\s*)?([A-E])\b/i,
+                /(?:^|\b)(?:a\s+)?(?:op[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|alternativa)\s+([A-E])\s*(?:├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®|e)\s*(?:a\s+)?(?:falsa|incorreta|errada)\b/i,
+                /(?:^|\b)(?:a\s+)?(?:op[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*[:\-]?\s*([A-E])\b/i,
+                // Common SERP phrasing: "A op├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬úo falsa ├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬® a e) ..."
+                /(?:^|\b)(?:a\s+)?(?:op[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|alternativa)\s+(?:falsa|incorreta|errada)\s*(?:├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®|e)\s*(?:a\s+)?([A-E])\s*[\)\.\-:]/i
             );
         }
 
@@ -1546,9 +1718,31 @@ export const SearchService = {
         let doc = null;
         let nodes = [];
         const safeHtml = sanitizeHtmlForParsing(rawHtml);
+
+        const extractNodes = (htmlDoc) => {
+            let extracted = Array.from(htmlDoc.querySelectorAll('div.t'));
+            const altNodes = Array.from(htmlDoc.querySelectorAll('.react-pdf__Page__textContent span, .textLayer span, [class*="textLayer"] span, [class*="textContent"] span'));
+            if (altNodes.length > extracted.length) extracted = altNodes;
+
+            if (extracted.length < 150) {
+                const els = Array.from(htmlDoc.querySelectorAll('p, span, li, td, mark, strong, b, div'));
+                const uniqueLeaves = els.filter(el => {
+                    if (!el.textContent.trim()) return false;
+                    // Only keep innermost elements to preserve exact nested styles (like background-color) 
+                    // without duplicating the text content for the anchor matching engine.
+                    if (el.firstElementChild && el.querySelector('p, span, li, td, mark, strong, b, div')) return false;
+                    return true;
+                });
+                if (uniqueLeaves.length > extracted.length) {
+                    extracted = uniqueLeaves;
+                }
+            }
+            return extracted;
+        };
+
         try {
             doc = new DOMParser().parseFromString(safeHtml, 'text/html');
-            nodes = Array.from(doc.querySelectorAll('div.t'));
+            nodes = extractNodes(doc);
         } catch {
             return { doc: null, nodes: [] };
         }
@@ -1567,7 +1761,7 @@ export const SearchService = {
                 .replace(/\\t/g, '\t');
             try {
                 const parsed = new DOMParser().parseFromString(sanitizeHtmlForParsing(decoded), 'text/html');
-                const parsedNodes = Array.from(parsed.querySelectorAll('div.t'));
+                const parsedNodes = extractNodes(parsed);
                 if (parsedNodes.length > nodes.length) {
                     doc = parsed;
                     nodes = parsedNodes;
@@ -1651,7 +1845,7 @@ export const SearchService = {
 
         const junkRatio = noVowelWords / Math.max(1, relevantWords.length);
         // Proportional consonant-run check: avoid false positives on pages with normal
-        // vowel ratios (Portuguese Ôëê 0.45) where a few CSS class names or encoded tokens
+        // vowel ratios (Portuguese ├»┬┐┬¢0├»┬┐┬¢ 0.45) where a few CSS class names or encoded tokens
         // happen to contain long consonant sequences.
         const consonantRunRatio = relevantWords.length > 0 ? longConsonantRuns / relevantWords.length : 0;
         const isObfuscated = (vowelRatio < 0.24 && junkRatio >= 0.28)
@@ -1683,7 +1877,7 @@ export const SearchService = {
             /conteudos?\s+liberados/i,
             /teste\s+gratis/i,
             /upload\s+para\s+desbloquear/i,
-            // Note: /paywall/i and /filter:blur/ removed ÔÇö they match CSS classes/styles
+            // Note: /paywall/i and /filter:blur/ removed ├»┬┐┬¢ they match CSS classes/styles
             // on content divs where the actual text IS readable in the DOM.
             /short-preview-version/i,
             /limitation-blocked/i,
@@ -1793,7 +1987,7 @@ export const SearchService = {
         }
 
         const anchorRe = /(resposta\s+correta|gabarito|alternativa\s+correta|resposta\s*:\s*letra)/i;
-        const stopRe = /(coment[a├âãÆ├é┬í]rio|resolu[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|explica[c├âãÆ├é┬º][a├âãÆ├é┬ú]o|pergunta\s+\d+|quest[a├âãÆ├é┬ú]o\s+\d+)/i;
+        const stopRe = /(coment[a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬í]rio|resolu[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|explica[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o|pergunta\s+\d+|quest[a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o\s+\d+)/i;
         let anchorIdx = -1;
         for (let i = 0; i < blockFrags.length; i += 1) {
             if (anchorRe.test(blockFrags[i].text)) {
@@ -1836,7 +2030,7 @@ export const SearchService = {
         };
     },
 
-    _extractAnswerCardEvidenceFromHtml(html, questionForInference, questionStem, originalOptionsMap, originalOptions) {
+    _extractAnswerCardEvidenceFromHtml(html, hostHint, questionForInference, questionStem, originalOptionsMap, originalOptions) {
         const { doc } = this._parseHtmlDomWithEmbeddedFallback(html);
         if (!doc) return null;
 
@@ -1853,6 +2047,10 @@ export const SearchService = {
             if (this._isLikelyObfuscatedText(text)) continue;
 
             const sim = this._questionSimilarityScore(text, questionStem);
+            // PASSEI DIRETO AUDIT: Increase similarity threshold for AnswerCards on PD to avoid cross-question contamination
+            const minSim = hostHint === 'passeidireto.com' ? 0.35 : 0.15;
+            if (sim < minSim) continue;
+
             const explicit = this._extractExplicitGabarito(text, questionForInference)
                 || this._extractExplicitLetterFromText(text, questionStem, originalOptions);
 
@@ -1861,6 +2059,14 @@ export const SearchService = {
             if (!letter) letter = this._findLetterByAnswerText(text, originalOptionsMap);
             if (!letter) continue;
 
+            // --- LOCAL HALLUCINATION GUARD (CROSS-QUESTION CONTAMINATION) ---
+            if (letterSource === 'explicit' && originalOptionsMap && originalOptionsMap[letter]) {
+                const expectedBody = this._normalizeOption(originalOptionsMap[letter]);
+                if (!this._isExplicitLetterSafe(text, letter, expectedBody)) {
+                    continue;
+                }
+            }
+
             const confidence = explicit?.letter ? 0.9 : 0.82;
             const score = confidence + (sim * 0.6);
             console.log(`    [answercard] candidate: letter=${letter} via=${letterSource} sim=${sim.toFixed(3)} score=${score.toFixed(3)} preview="${text.slice(0, 120)}"`);
@@ -1888,10 +2094,10 @@ export const SearchService = {
         if (!fullText || fullText.length < 120) return null;
         if (this._isLikelyObfuscatedText(fullText)) return null;
 
-        const noisyContextRe = /(resposta\s+gerada\s+por\s+ia|desbloqueie|premium|ajude\s+estudantes|conte[├âãÆ├é┬║u]dos\s+liberados|respostas?\s+dispon[├âãÆ├é┬¡i]veis\s+nesse\s+material)/i;
-        const strongAnchorRe = /(gabarito|resposta\s+correta|resposta\s*:\s*(?:letra\s*)?[A-E]|a\s+resposta\s+[e├âãÆ├é┬®]|alternativa\s+correta\s*(?:[e├âãÆ├é┬®]|[:\-]))/i;
-        const anchorRe = /(gabarito|resposta\s+correta|alternativa\s+correta|resposta\s*:\s*letra|a\s+resposta\s+[e├âãÆ├é┬®])/ig;
-        const directiveRe = /(assinale|marque|selecione|indique)\s+(?:a\s+)?(?:alternativa|afirmativa|op[c├âãÆ├é┬º][a├âãÆ├é┬ú]o)\s+(?:correta|incorreta|falsa|errada)/i;
+        const noisyContextRe = /(resposta\s+gerada\s+por\s+ia|desbloqueie|premium|ajude\s+estudantes|conte[├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬║u]dos\s+liberados|respostas?\s+dispon[├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬¡i]veis\s+nesse\s+material)/i;
+        const strongAnchorRe = /(gabarito|resposta\s+correta|resposta\s*:\s*(?:letra\s*)?[A-E]|a\s+resposta\s+[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®]|alternativa\s+correta\s*(?:[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®]|[:\-]))/i;
+        const anchorRe = /(gabarito|resposta\s+correta|alternativa\s+correta|resposta\s*:\s*letra|a\s+resposta\s+[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®])/ig;
+        const directiveRe = /(assinale|marque|selecione|indique)\s+(?:a\s+)?(?:alternativa|afirmativa|op[c├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬º][a├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬ú]o)\s+(?:correta|incorreta|falsa|errada)/i;
         const riskyHost = hostHint === 'passeidireto.com' || hostHint === 'brainly.com.br' || hostHint === 'brainly.com';
         const candidates = [];
         let m;
@@ -1910,7 +2116,7 @@ export const SearchService = {
             if (noisyContextRe.test(ctx)) continue;
             const hasStrongAnchorSignal = strongAnchorRe.test(ctx);
             if (!hasStrongAnchorSignal) continue;
-            if (directiveRe.test(ctx) && !/(gabarito|resposta\s+correta|a\s+resposta\s+[e├âãÆ├é┬®]|resposta\s*:)/i.test(ctx)) continue;
+            if (directiveRe.test(ctx) && !/(gabarito|resposta\s+correta|a\s+resposta\s+[e├âÔÇÖ├»┬┐┬¢├»┬┐┬¢├é┬®]|resposta\s*:)/i.test(ctx)) continue;
 
             const sim = this._questionSimilarityScore(ctx, questionStem);
             if (sim < (riskyHost ? 0.22 : 0.16)) continue;
@@ -1989,9 +2195,9 @@ export const SearchService = {
             return { skip: true, reason: 'paywall-overlay', diagnostics: { type, obfuscation, paywall } };
         }
 
-        if (type === 'TYPE_PD_PDF_HTML' || hostHint === 'passeidireto.com' || hostHint === 'studocu.com') {
+        if (type === 'TYPE_PD_PDF_HTML' || hostHint === 'studocu.com') {
             const byAnchor = this._extractPdfLikeAnswerByAnchors(html, questionForInference, questionStem, originalOptionsMap, originalOptions);
-            console.log(`    [Structured] PDF anchor: letter=${byAnchor?.letter || 'none'} method=${byAnchor?.method || 'none'}`);
+            console.log(`    [Structured] ${hostHint} PDF anchor: letter=${byAnchor?.letter || 'none'} method=${byAnchor?.method || 'none'}`);
             if (byAnchor?.letter) {
                 return {
                     ...byAnchor,
@@ -2001,8 +2207,21 @@ export const SearchService = {
             }
         }
 
+        // AUDIT: Passei Direto Specific Path - Decoupled from Studocu to avoid regression
+        if (hostHint === 'passeidireto.com') {
+            const byAnchor = this._extractPdfLikeAnswerByAnchors(html, questionForInference, questionStem, originalOptionsMap, originalOptions);
+            if (byAnchor?.letter && byAnchor.matchQuality > 0.4) {
+                console.log(`    [Structured] PasseiDireto PDF anchor HIT: letter=${byAnchor.letter}`);
+                return {
+                    ...byAnchor,
+                    evidenceType: `passeidireto-pdf-scoped`,
+                    diagnostics: { type, obfuscation, paywall }
+                };
+            }
+        }
+
         if (type === 'TYPE_PD_ANSWERCARD') {
-            const byAnswerCard = this._extractAnswerCardEvidenceFromHtml(html, questionForInference, questionStem, originalOptionsMap, originalOptions);
+            const byAnswerCard = this._extractAnswerCardEvidenceFromHtml(html, hostHint, questionForInference, questionStem, originalOptionsMap, originalOptions);
             console.log(`    [Structured] AnswerCard: letter=${byAnswerCard?.letter || 'none'} method=${byAnswerCard?.method || 'none'}`);
             if (byAnswerCard?.letter) {
                 return {
@@ -2042,7 +2261,7 @@ export const SearchService = {
         console.log(`    [ff1-highlight] check: 'ff4' occurrences: ${(html.match(/ff4/g) || []).length}`);
         console.log(`    [ff1-highlight] check: 'div.t' nodes extracted: ${nodes.length}`);
 
-        if (nodes.length < 50) return null;
+        if (nodes.length < 15) return null;
 
         const frags = nodes
             .map((n) => ({
@@ -2054,7 +2273,7 @@ export const SearchService = {
             .filter(f => f.text && f.text.length >= 1);
 
         console.log(`    [ff1-highlight] check: frags_len=${frags.length}`);
-        if (frags.length < 50) return null;
+        if (frags.length < 15) return null;
 
         // Find the best anchor position for the question block.
         // Use a small rolling window because PDF-like exports often split words across many fragments.
@@ -2083,17 +2302,29 @@ export const SearchService = {
         const windowFrags = frags.slice(windowStart, Math.min(frags.length, bestIdx + 520));
         const windowText = windowFrags.map(f => f.text).join('\n');
 
-        // Options evidence gate: require at least 2 option bodies present in this window.
-        const optBodies = Object.values(originalOptionsMap || {}).map(v => this._normalizeOption(v)).filter(v => v.length >= 8);
+        // Options evidence gate: require at least 1 option body present in this window.
+        // We filter out extremely short noise options (< 3 chars) but allow short 
+        // acronyms like "XML" to be matched via word boundaries to avoid false positives.
+        const validBodies = Object.values(originalOptionsMap || {})
+            .map(v => this._normalizeOption(v))
+            .filter(v => v.length >= 3);
+
         let optionHits = 0;
         const normWindow = this._normalizeOption(windowText);
+        const normWindowSpaced = ` ${normWindow} `; // For word boundary check on short words
         const optionHitDetails = [];
-        for (const body of optBodies) {
-            const hit = body && normWindow.includes(body);
+
+        for (const body of validBodies) {
+            let hit = false;
+            if (body && body.length >= 8) {
+                hit = normWindow.includes(body);
+            } else if (body && body.length >= 3) {
+                hit = normWindowSpaced.includes(` ${body} `);
+            }
             if (hit) optionHits += 1;
             optionHitDetails.push({ body: body?.slice(0, 50), hit: !!hit });
         }
-        console.log(`    [ff1-highlight] optionHits=${optionHits}/${optBodies.length} windowLen=${windowText.length}`);
+        console.log(`    [ff1-highlight] optionHits=${optionHits}/${validBodies.length} windowLen=${windowText.length}`);
         console.log(`    [ff1-highlight] optionDetails:`, JSON.stringify(optionHitDetails));
         // Show anchor context to understand which question was found
         const anchorContextStart = Math.max(0, bestIdx - windowStart - 3);
@@ -2121,23 +2352,11 @@ export const SearchService = {
             return /^(?:\)?\s*)?\d{1,3}\s*[\)\.\-:]\s*/.test(s) || /^aula\s+\d+/i.test(s);
         };
 
-        // FIX: Clip option grouping to start near the anchor, NOT from the full
-        // lookback window.  The -80 lookback is kept for context (options evidence
-        // gate) but must NOT feed into option grouping, otherwise the PREVIOUS
-        // question's highlighted answer contaminates the current question.
-        // We scan backward from the anchor (max 15 frags) and stop at the nearest
-        // question-start marker so we never cross a question boundary.
+        // FIX: Start option grouping right at the anchor, NOT from a backward scan.
+        // The previous backward scan (-15) caused it to pick up the PREVIOUS question's 
+        // options if the question marker regex failed to block it. Options are always AFTER the stem.
         const anchorOffset = bestIdx - windowStart;            // anchor position within windowFrags
-        const maxGroupLookback = Math.min(anchorOffset, 15);   // cap backward scan
-        let groupStartOffset = anchorOffset;                   // default: start at anchor
-        for (let g = anchorOffset - 1; g >= anchorOffset - maxGroupLookback; g--) {
-            if (g < 0) break;
-            if (isNextQuestionMarker(windowFrags[g].text)) {
-                groupStartOffset = g + 1;                      // don't include prev question marker
-                break;
-            }
-            groupStartOffset = g;                              // extend backward tentatively
-        }
+        const groupStartOffset = anchorOffset;
         const groupingFrags = windowFrags.slice(groupStartOffset);
 
         for (const f of groupingFrags) {
@@ -2171,7 +2390,7 @@ export const SearchService = {
             const ffClasses = gf.map(f => f.cls).join(' ').match(/ff\d+/g) || [];
             console.log(`    [ff1-highlight]   ${gl}) "${bodyPreview}" ffClasses=[${[...new Set(ffClasses)].join(',')}]`);
         }
-        if (originalOptions && originalOptions.length >= 2 && optionHits < 1) {
+        if (originalOptions && originalOptions.length >= 2 && validBodies.length > 0 && optionHits < 1) {
             console.log(`    [ff1-highlight] REJECTED: 0 option-body matches in window (letters=${letters.length})`);
             return null;
         }
@@ -2210,9 +2429,19 @@ export const SearchService = {
                 }
                 const allTokens = [...clsTokens, ...nestedClassTokens];
                 for (const token of allTokens) {
-                    if (!/^(ff|fs|fc|sc|ls)\d+$/i.test(token)) continue;
+                    // Filter out highly variable coordinates to reduce noise (like x10, y20, h4, w2, m0, _, _1a).
+                    // BUT keep anything that might be a font, color, or style feature (like ff1, bold, bg-red).
+                    const isNoise = /^(x|y|h|w|m|c|ws|yc)\d+$/i.test(token) || /^_/.test(token) || token === 't';
+                    if (isNoise && !/^(ff|fs|fc|sc|ls|bg)\d+$/i.test(token)) continue;
+
                     classTokenCounts.set(token, (classTokenCounts.get(token) || 0) + 1);
                 }
+
+                // Extra├â┬º├â┬úo especial: Marca├â┬º├â┬úo de cor de fundo inline (ex: background-color: rgb(255, 255, 0);) 
+                // muito comum no Studocu e em prints grifados.
+                if (/background-color\s*:\s*([^;]+)/i.test(p.style)) {
+                    classTokenCounts.set('inline-bg-highlight', (classTokenCounts.get('inline-bg-highlight') || 0) + 1);
+                }
             }
 
             featuresByLetter[letter] = {
@@ -2269,13 +2498,13 @@ export const SearchService = {
         console.log(`    [ff1-highlight] Strategy1: bestLetter=${bestLetter} bestScore=${bestScore} secondScore=${secondScore}`);
 
         if (bestLetter && bestScore >= 1 && bestScore > secondScore) {
-            console.log(`    [ff1-highlight] Strategy1 HIT: raw=${bestLetter} ÔÇö calling remap...`);
+            console.log(`    [ff1-highlight] Strategy1 HIT: raw=${bestLetter} ├»┬┐┬¢ calling remap...`);
             const remappedFf1 = this._remapLetterToUserOptions(bestLetter, sourceOptionsFromGroups, originalOptionsMap);
             console.log(`    [ff1-highlight] Strategy1 RESULT: raw=${bestLetter} remapped=${remappedFf1}`);
             const verified = this._verifyHighlightMatch(bestLetter, remappedFf1, sourceOptionsFromGroups, originalOptionsMap, 0.95);
             if (!verified) {
-                console.log(`    [ff1-highlight] Strategy1 REJECTED by content verification ÔÇö wrong question anchor`);
-                // Don't return here ÔÇö fall through to Strategy 1.5/2
+                console.log(`    [ff1-highlight] Strategy1 REJECTED by content verification ├»┬┐┬¢ wrong question anchor`);
+                // Don't return here ├»┬┐┬¢ fall through to Strategy 1.5/2
             } else {
                 return {
                     letter: verified.letter,
@@ -2286,15 +2515,17 @@ export const SearchService = {
             }
         }
 
-        // Strategy 1.5: font-family outlier detection.
-        // If most options share one dominant ff* class (e.g. ff3) but one option
-        // has a DIFFERENT ff* class (e.g. ff2) unique to it, that option is highlighted.
+        // Strategy 1.5: Generalized CSS Replacement Outlier Detection.
+        // If most options share one dominant class (like 'ff3' or 'font-normal')
+        // but ONE option is missing it and has a DIFFERENT class ('ff2' or 'font-bold') 
+        // unique to it, that option is highlighted as the outlier.
         const ffCountsByLetter = {};
         const ffGlobalCounts = new Map();
         for (const [letter, feat] of Object.entries(featuresByLetter)) {
             const localFf = new Map();
             for (const [token, count] of feat.classTokenCounts.entries()) {
-                if (!/^ff\d+$/i.test(token)) continue;
+                // Focus on likely styling tokens for direct swaps, avoiding noise tokens like letter-spacing.
+                if (/^ls\d+$/i.test(token) || /^(sc|ws)\d+$/i.test(token)) continue;
                 localFf.set(token, count);
                 ffGlobalCounts.set(token, (ffGlobalCounts.get(token) || 0) + count);
             }
@@ -2330,7 +2561,7 @@ export const SearchService = {
                 const outlier = outliers[0];
                 console.log(`SearchService: ff-outlier detected: letter=${outlier.letter} outlier_ff=${outlier.token} dominant_ff=${globalDominantFf}`);
                 const remappedOutlier = this._remapLetterToUserOptions(outlier.letter, sourceOptionsFromGroups, originalOptionsMap);
-                console.log(`    [ff-outlier] remap raw=${outlier.letter} ÔåÆ ${remappedOutlier}`);
+                console.log(`    [ff-outlier] remap raw=${outlier.letter} ├»┬┐┬¢  ${remappedOutlier}`);
                 const outlierConf = this._verifyHighlightMatch(outlier.letter, remappedOutlier, sourceOptionsFromGroups, originalOptionsMap, 0.93);
                 if (!outlierConf) {
                     console.log(`    [ff-outlier] REJECTED by content verification`);
@@ -2345,7 +2576,8 @@ export const SearchService = {
             }
         }
 
-        // Strategy 2: CSS signature outlier between alternatives (encrypted/blurred pages).
+        // Strategy 2: Generalized CSS signature outlier between alternatives.
+        // Even if they change classes from 'ff1' to 'bold' or 'font-hightlight', we catch the unique CSS print.
         const signatureScores = {};
         for (const letter of letters) {
             const feat = featuresByLetter[letter];
@@ -2353,7 +2585,15 @@ export const SearchService = {
             for (const [token, count] of feat.classTokenCounts.entries()) {
                 const owners = tokenOwners.get(token);
                 if (!owners || owners.size !== 1) continue;
-                const base = token.startsWith('ff') ? 1.3 : token.startsWith('ls') ? 0.6 : 0.8;
+
+                // Favor known font/color styling traits, but give generic unique classes a fair weight too
+                let base = 1.0;
+                if (/^(ff|fc|fs|bg)\d+$/i.test(token) || /bold|color|bg|highlight|strong|mark|inline-bg-highlight/i.test(token)) {
+                    base = 3.5;
+                } else if (/^ls\d+$/i.test(token)) {
+                    base = 0.6; // letter-spacing is often noise
+                }
+
                 uniqueTokenScore += base * Math.min(2, count);
             }
 
@@ -2382,12 +2622,15 @@ export const SearchService = {
         const sigFeat = featuresByLetter[sigBestLetter];
         const hasReasonableSupport = sigFeat && sigFeat.fragCount >= 1;
         const strongOutlier = sigBestScore >= 1.8 && sigMargin >= 0.8;
-        const permissiveOutlier = sigBestScore >= 2.4 && sigMargin >= 0.5 && optionHits >= 1;
+        const permissiveOutlier = sigBestScore >= 2.4 && sigMargin >= 0.5 && optionHits >= 0; // relaxed for partial views
 
-        if (!hasReasonableSupport || (!strongOutlier && !permissiveOutlier)) return null;
+        if (!hasReasonableSupport || (!strongOutlier && !permissiveOutlier)) {
+            console.log(`    [css-signature] REJECTED: bestScore=${sigBestScore} margin=${sigMargin} frags=${sigFeat?.fragCount || 0}`);
+            return null;
+        }
 
         const remappedSig = this._remapLetterToUserOptions(sigBestLetter, sourceOptionsFromGroups, originalOptionsMap);
-        console.log(`    [css-signature] remap raw=${sigBestLetter} ÔåÆ ${remappedSig}`);
+        console.log(`    [css-signature] remap raw=${sigBestLetter} ├»┬┐┬¢  ${remappedSig}`);
         const sigConf = this._verifyHighlightMatch(sigBestLetter, remappedSig, sourceOptionsFromGroups, originalOptionsMap,
             Math.max(0.82, Math.min(0.9, 0.82 + (sigMargin * 0.06))));
         if (!sigConf) {
@@ -2606,14 +2849,22 @@ export const SearchService = {
             } else if (hasAnyNonAi && bestNonAi.length >= 1 && bestScore >= 3.0) {
                 // Single high-quality non-AI source with decent weight: promote to "suggested"
                 // This handles cases where only one source (e.g. PDF-highlight) produced
-                // a clear answer ÔÇö better than "inconclusive" even if we can't fully confirm.
+                // a clear answer ├»┬┐┬¢ better than "inconclusive" even if we can't fully confirm.
                 const hasHighQualityMethod = bestNonAi.some(s => {
                     const et = String(s.evidenceType || '').toLowerCase();
-                    return et.includes('pdf') || et.includes('highlight') || et.includes('answercard') || et.includes('gabarito');
+                    const sm = String(s.extractionMethod || '').toLowerCase();
+                    return et.includes('pdf') || et.includes('highlight') || et.includes('answercard') || et.includes('gabarito') ||
+                        sm.includes('pdf') || sm.includes('highlight') || sm.includes('answercard') || sm.includes('gabarito') || sm.includes('anchor');
                 });
+
                 if (hasHighQualityMethod || hasDomainConsensus) {
-                    resultState = 'suggested';
-                    reason = 'ai_combined_suggestion';
+                    if (bestScore > 5.5) {
+                        resultState = 'confirmed'; // Promote a very high weighted single domain back to confirmed
+                        reason = 'confirmed_by_high_weight_source';
+                    } else {
+                        resultState = 'suggested';
+                        reason = 'single_high_quality_source';
+                    }
                 }
             } else if (bestScore > 0 && !hasAnyNonAi && sources.length >= 1) {
                 // AI-only evidence (from combined inference): show as suggested
@@ -2687,9 +2938,9 @@ export const SearchService = {
             if (hasOptions) {
                 return [{
                     question: questionText,
-                    answer: 'INCONCLUSIVO: sem evid├¬ncia externa confi├ível para marcar alternativa.',
+                    answer: 'INCONCLUSIVO: sem evid├â┬¬ncia externa confi├â┬ível para marcar alternativa.',
                     answerLetter: null,
-                    answerText: 'Sem evid├¬ncia externa confi├ível para marcar alternativa.',
+                    answerText: 'Sem evid├â┬¬ncia externa confi├â┬ível para marcar alternativa.',
                     aiFallback: true,
                     evidenceTier: 'AI_ONLY',
                     resultState: 'inconclusive',
@@ -2710,7 +2961,7 @@ export const SearchService = {
                 question: questionText,
                 answer: aiAnswer,
                 answerLetter: null,
-                answerText: 'Sem evid├¬ncia suficiente para marcar alternativa.',
+                answerText: 'Sem evid├â┬¬ncia suficiente para marcar alternativa.',
                 aiFallback: true,
                 evidenceTier: 'AI_ONLY',
                 resultState: 'inconclusive',
@@ -2767,12 +3018,12 @@ export const SearchService = {
         const originalOptionsMap = this._buildOptionsMap(questionForInference);
         const hasOptions = originalOptions && originalOptions.length >= 2;
 
-        // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É Detect question polarity ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+        // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É Detect question polarity ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
         const questionPolarity = this._detectQuestionPolarity(questionStem);
         console.log(`SearchService: Polarity detected: ${questionPolarity}`);
 
-        // ÔòÉÔòÉÔòÉ DEBUG: Pipeline Start ÔòÉÔòÉÔòÉ
-        console.group('­ƒöì SearchService DEBUG ÔÇö Pipeline Start');
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ DEBUG: Pipeline Start ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+        console.group('├»┬┐┬¢x├»┬┐┬¢ SearchService DEBUG ├»┬┐┬¢ Pipeline Start');
         console.log('Question stem:', questionStem.slice(0, 120));
         console.log('Options extracted:', originalOptions);
         console.log('Has options:', hasOptions, '| Options count:', originalOptions.length);
@@ -2841,8 +3092,26 @@ export const SearchService = {
                 `SearchService: RunSummary outcome=${outcome} analyzed=${runStats.analyzed} acceptedVotes=${runStats.acceptedForVotes} acceptedAi=${runStats.acceptedForAiEvidence} aiExtraction=${runStats.acceptedViaAiExtraction} knowledgePool=${aiKnowledgePool.length} blockedPaywall=${runStats.blockedPaywall} blockedObf=${runStats.blockedObfuscation} blockedMismatch=${runStats.blockedOptionsMismatch} blockedSnapshotMismatch=${runStats.blockedSnapshotMismatch} blockedErrors=${runStats.blockedByError}`
             );
         };
+        const shouldEarlyExit = (bestLetter, votes) => {
+            const score = votes?.[bestLetter] || 0;
+            if (!bestLetter || score < 6.5) return false;
+
+            const supporters = sources.filter((s) => s.letter === bestLetter);
+            if (supporters.length >= 2) return true;
+            if (supporters.length !== 1) return false;
+
+            const only = supporters[0] || {};
+            const evidenceType = String(only.evidenceType || '').toLowerCase();
+            const strongSingleSource = evidenceType.includes('explicit-gabarito')
+                || evidenceType.includes('pdf-anchor-gabarito')
+                || evidenceType.includes('answercard')
+                || evidenceType.includes('google-answerbox')
+                || evidenceType.includes('google-ai-overview');
+
+            return strongSingleSource && (only.weight || 0) >= 5.6;
+        };
 
-        // ÔòÉÔòÉÔòÉ GOOGLE AI OVERVIEW / ANSWER BOX / PEOPLE ALSO ASK ÔòÉÔòÉÔòÉ
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ GOOGLE AI OVERVIEW / ANSWER BOX / PEOPLE ALSO ASK ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
         // Process Serper meta signals (answerBox, aiOverview, peopleAlsoAsk)
         // as high-priority evidence BEFORE iterating page sources.
         // These come for free with the Serper API response.
@@ -2855,7 +3124,7 @@ export const SearchService = {
             peopleAlsoAsk: Array.isArray(serperMeta?.peopleAlsoAsk) ? serperMeta.peopleAlsoAsk.length > 0 : !!serperMeta?.peopleAlsoAsk
         };
         if (serperMeta && hasOptions) {
-            console.group('­ƒîÉ Google Meta Signals (answerBox / AI Overview / PAA)');
+            console.group('├»┬┐┬¢xR├»┬┐┬¢ Google Meta Signals (answerBox / AI Overview / PAA)');
             console.log('answerBox:', serperMeta.answerBox ? 'present' : 'absent');
             console.log('aiOverview:', serperMeta.aiOverview ? 'present' : 'absent');
             console.log('peopleAlsoAsk:', serperMeta.peopleAlsoAsk ? `${serperMeta.peopleAlsoAsk.length} entries` : 'absent');
@@ -2892,9 +3161,9 @@ export const SearchService = {
                     evidenceBlock
                 });
                 runStats.acceptedForVotes += 1;
-                console.log(`  Ô£à Google meta ACCEPTED: letter=${googleMeta.letter} method=${googleMeta.method} weight=${adjustedWeight.toFixed(2)} confidence=${(googleMeta.confidence || 0).toFixed(2)}`);
+                console.log(`  ├»┬┐┬¢S& Google meta ACCEPTED: letter=${googleMeta.letter} method=${googleMeta.method} weight=${adjustedWeight.toFixed(2)} confidence=${(googleMeta.confidence || 0).toFixed(2)}`);
             } else {
-                console.log('  Ôä╣´©Å No answer letter extracted from Google meta signals');
+                console.log('  ├»┬┐┬¢├»┬┐┬¢├»┬©┬Å No answer letter extracted from Google meta signals');
                 // Still collect answerBox/aiOverview text as evidence for AI combined
                 const metaTexts = [];
                 if (serperMeta.answerBox) {
@@ -2924,46 +3193,65 @@ export const SearchService = {
                             obfuscated: false,
                             paywalled: false
                         });
-                        console.log(`  ­ƒôØ Google meta text collected for AI combined (topicSim=${topicSim.toFixed(2)}, len=${combinedMeta.length})`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Google meta text collected for AI combined (topicSim=${topicSim.toFixed(2)}, len=${combinedMeta.length})`);
                     }
                 }
             }
             console.groupEnd();
         }
 
-        // ÔòÉÔòÉÔòÉ PARALLEL PAGE FETCH ÔòÉÔòÉÔòÉ
-        // Fetch all pages concurrently instead of sequentially.
-        // Sequential: 10 ├ù (0.25s delay + ~2s fetch) Ôëê 22s
-        // Parallel (5 workers): ~4-7s (limited by slowest page)
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ CHUNKING PARALLEL PAGE FETCH & CACHING ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+        if (!this._urlCache) this._urlCache = new Map();
+
         if (typeof onStatus === 'function') {
-            onStatus(`Fetching ${topResults.length} sources in parallel...`);
+            onStatus(`Buscando fontes em lotes para acelerar a resposta...`);
         }
         const _prefetchedSnaps = new Map();
-        {
-            let _fetchIdx = 0;
-            const _fetchWorkers = Array.from(
-                { length: Math.min(5, topResults.length) },
-                async () => {
-                    while (_fetchIdx < topResults.length) {
-                        const _r = topResults[_fetchIdx++];
-                        try {
-                            const snap = await ApiService.fetchPageSnapshot(_r.link, {
-                                timeoutMs: 6500,
-                                maxHtmlChars: 1500000,
-                                maxTextChars: 12000
-                            });
-                            _prefetchedSnaps.set(_r.link, snap);
-                        } catch (e) {
-                            _prefetchedSnaps.set(_r.link, null);
+
+        // Iterate through all results but fetch them dynamically in batches of 5
+        let _loopIndex = 0;
+        let earlyExitTriggered = false;
+
+        for (const result of topResults) {
+            if (earlyExitTriggered) break;
+
+            if (_loopIndex % 5 === 0) {
+                const currentBatch = topResults.slice(_loopIndex, _loopIndex + 5);
+                if (typeof onStatus === 'function') {
+                    onStatus(`Carregando lote ${Math.floor(_loopIndex / 5) + 1} (${currentBatch.length} fontes)...`);
+                }
+
+                let _fetchIdx = 0;
+                const _fetchWorkers = Array.from(
+                    { length: Math.min(5, currentBatch.length) },
+                    async () => {
+                        while (_fetchIdx < currentBatch.length) {
+                            const _r = currentBatch[_fetchIdx++];
+                            if (this._urlCache.has(_r.link)) {
+                                _prefetchedSnaps.set(_r.link, this._urlCache.get(_r.link));
+                                continue;
+                            }
+                            try {
+                                const snap = await ApiService.fetchPageSnapshot(_r.link, {
+                                    timeoutMs: 6500,
+                                    maxHtmlChars: 1500000,
+                                    maxTextChars: 12000
+                                });
+                                _prefetchedSnaps.set(_r.link, snap);
+                                this._urlCache.set(_r.link, snap);
+                                // Clear cache if it gets too large
+                                if (this._urlCache.size > 100) this._urlCache.clear();
+                            } catch (e) {
+                                _prefetchedSnaps.set(_r.link, null);
+                            }
                         }
                     }
-                }
-            );
-            await Promise.all(_fetchWorkers);
-        }
-        console.log(`SearchService: Parallel fetch complete ÔÇö ${_prefetchedSnaps.size}/${topResults.length} pages fetched`);
+                );
+                await Promise.all(_fetchWorkers);
+                console.log(`SearchService: Batched fetch concluded ├»┬┐┬¢ fetched ${currentBatch.length} pages in this cycle`);
+            }
+            _loopIndex++;
 
-        for (const result of topResults) {
             try {
                 const snippet = result.snippet || '';
                 const title = result.title || '';
@@ -2978,15 +3266,15 @@ export const SearchService = {
 
                 const pageText = (snap?.text || '').trim();
                 const combinedText = `${title}. ${snippet}\n\n${pageText}`.trim();
-                const scopedCombinedText = this._buildQuestionScopedText(combinedText, questionForInference, 3600);
-                console.log(`  ­ƒôÉ scopedCombinedText length=${scopedCombinedText.length} (full combined=${combinedText.length}) preview="${scopedCombinedText.slice(0, 200)}"`);
+                const scopedCombinedText = this._buildQuestionScopedText(combinedText, questionForInference, 3600, originalOptions);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ scopedCombinedText length=${scopedCombinedText.length} (full combined=${combinedText.length}) preview="${scopedCombinedText.slice(0, 200)}"`);
                 const seedText = `${title}. ${snippet}`.trim();
                 const snapshotWeak = !snap?.ok || pageText.length < 120;
                 if (snapshotWeak && hasOptions) {
                     const seedCoverage = this._optionsCoverageInFreeText(originalOptions, seedText);
                     const seedTopicSim = this._questionSimilarityScore(seedText, questionStem);
                     // When topicSim is very high (the snippet clearly describes the same question),
-                    // relax the option coverage requirement ÔÇö the snippet may simply be truncated.
+                    // relax the option coverage requirement ├»┬┐┬¢ the snippet may simply be truncated.
                     const highTopicSim = seedTopicSim >= 0.85;
                     const minHitsForStrong = highTopicSim
                         ? Math.min(2, seedCoverage.total || 2)
@@ -3019,8 +3307,8 @@ export const SearchService = {
                 let paywall = this._paywallSignals(htmlText, docText, hostHint);
                 const topicSimBase = this._questionSimilarityScore(combinedText, questionStem);
 
-                // ÔòÉÔòÉÔòÉ DEBUG: Source Fetch ÔòÉÔòÉÔòÉ
-                console.group(`­ƒôä Source #${runStats.analyzed}: ${hostHint}`);
+                // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ DEBUG: Source Fetch ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+                console.group(`├»┬┐┬¢x Source #${runStats.analyzed}: ${hostHint}`);
                 console.log('Link:', link);
                 console.log('Fetch OK:', snap?.ok, '| HTML length:', htmlText.length, '| Text length:', pageText.length);
                 console.log('Source type:', sourceType);
@@ -3042,7 +3330,7 @@ export const SearchService = {
                         optionsMatchBase = true;
                         console.log(`SearchService: Options matched via full-text fallback for ${hostHint} (hits=${fullCoverage.hits}/${fullCoverage.total})`);
                     } else {
-                        console.log(`  ÔØî Full-text options fallback also failed: hits=${fullCoverage.hits}/${fullCoverage.total} ratio=${fullCoverage.ratio.toFixed(2)}`);
+                        console.log(`  ├»┬┐┬¢R Full-text options fallback also failed: hits=${fullCoverage.hits}/${fullCoverage.total} ratio=${fullCoverage.ratio.toFixed(2)}`);
                     }
                 }
                 console.log('Options match:', optionsMatchBase, '| Coverage:', JSON.stringify(optionsCoverageBase));
@@ -3063,9 +3351,9 @@ export const SearchService = {
                     // readable in the DOM despite paywall CSS (blur/overlay). Only block
                     // when text is truly empty or very short.
                     const readableTextLen = (docText || '').length;
-                    console.log(`  ­ƒöÆ Paywall detected: readableTextLen=${readableTextLen}`);
+                    console.log(`  ├»┬┐┬¢x Paywall detected: readableTextLen=${readableTextLen}`);
                     if (readableTextLen < 400) {
-                        console.log(`  Ôøö BLOCKED: paywall-overlay (text too short: ${readableTextLen} < 400)`);
+                        console.log(`  ├»┬┐┬¢: BLOCKED: paywall-overlay (text too short: ${readableTextLen} < 400)`);
                         console.groupEnd();
                         runStats.blockedPaywall += 1;
                         this._logSourceDiagnostic({
@@ -3081,16 +3369,16 @@ export const SearchService = {
                         });
                         continue;
                     }
-                    // Content IS readable ÔÇö proceed with extraction despite paywall signals.
+                    // Content IS readable ├»┬┐┬¢ proceed with extraction despite paywall signals.
                     // Clear the paywall flag so downstream extractors (structured, PDF-highlight,
                     // local regex) don't redundantly re-block this source.
                     paywall = { ...paywall, isPaywalled: false, softPassed: true };
-                    console.log(`  Ô£à Paywall SOFT-PASSED: text readable (${readableTextLen} chars) ÔÇö flag cleared`);
+                    console.log(`  ├»┬┐┬¢S& Paywall SOFT-PASSED: text readable (${readableTextLen} chars) ├»┬┐┬¢ flag cleared`);
                 }
 
                 if (obfuscation?.isObfuscated) {
-                    console.log(`  Ôøö BLOCKED: obfuscated HTML`);
-                    // Still collect for AI combined if topic similarity is decent ÔÇö
+                    console.log(`  ├»┬┐┬¢: BLOCKED: obfuscated HTML`);
+                    // Still collect for AI combined if topic similarity is decent ├»┬┐┬¢
                     // the combined pass uses title + snippet + text, not raw HTML.
                     if (topicSimBase >= 0.30 && !paywall?.isPaywalled) {
                         const clipped = scopedCombinedText.slice(0, 3000);
@@ -3137,7 +3425,7 @@ export const SearchService = {
                 // However, high-similarity sources are still collected for AI combined inference
                 // AND can contribute knowledge via AI extraction.
                 if (hasOptions && !optionsMatchBase && !allowStructuredMismatchBypass) {
-                    console.log(`  Ôøö BLOCKED: options-mismatch-hard-block (topicSim=${topicSimBase.toFixed(3)})`);
+                    console.log(`  ├»┬┐┬¢: BLOCKED: options-mismatch-hard-block (topicSim=${topicSimBase.toFixed(3)})`);
                     // Collect sources with decent topic similarity for AI combined pass.
                     // Allow paywalled-but-readable sources (they passed the soft-block above).
                     if (topicSimBase >= 0.25 && !obfuscation?.isObfuscated) {
@@ -3160,8 +3448,8 @@ export const SearchService = {
                     // Even though options don't match, the page may contain relevant knowledge
                     // about the topic that can help in the combined reflection step.
                     if (aiExtractionCount < 5 && topicSimBase >= 0.50 && !obfuscation?.isObfuscated && scopedCombinedText.length >= 300) {
-                        const aiScopedText = this._buildQuestionScopedText(combinedText, questionForInference, 8000);
-                        console.log(`  ­ƒñû [AI-MISMATCH] Attempting knowledge extraction from mismatch source (call ${aiExtractionCount + 1}/5, topicSim=${topicSimBase.toFixed(3)}, textLen=${aiScopedText.length}, host=${hostHint})`);
+                        const aiScopedText = this._buildQuestionScopedText(combinedText, questionForInference, 8000, originalOptions);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-MISMATCH] Attempting knowledge extraction from mismatch source (call ${aiExtractionCount + 1}/5, topicSim=${topicSimBase.toFixed(3)}, textLen=${aiScopedText.length}, host=${hostHint})`);
                         if (typeof onStatus === 'function') {
                             onStatus(`AI extracting knowledge from ${hostHint || 'source'}...`);
                         }
@@ -3170,7 +3458,7 @@ export const SearchService = {
                             aiExtractionCount++;
 
                             if (aiExtracted?.knowledge) {
-                                // Strip letter/resultado claims from knowledge ÔÇö the letter is
+                                // Strip letter/resultado claims from knowledge ├»┬┐┬¢ the letter is
                                 // from a different question set and would poison reflection
                                 const cleanKnowledge = aiExtracted.knowledge
                                     .replace(/^RESULTADO:\s*ENCONTRADO\s*$/gim, '')
@@ -3184,15 +3472,15 @@ export const SearchService = {
                                     title,
                                     origin: 'mismatch'
                                 });
-                                console.log(`  ­ƒñû [AI-MISMATCH] Knowledge collected: ${cleanKnowledge.length} chars (pool size=${aiKnowledgePool.length})`);
+                                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-MISMATCH] Knowledge collected: ${cleanKnowledge.length} chars (pool size=${aiKnowledgePool.length})`);
                             }
                             // Even if AI finds a letter, we DON'T use it for voting because
-                            // options don't match ÔÇö the letter may correspond to a different set of options.
+                            // options don't match ├»┬┐┬¢ the letter may correspond to a different set of options.
                             if (aiExtracted?.letter) {
-                                console.log(`  ­ƒñû [AI-MISMATCH] Letter ${aiExtracted.letter} found but IGNORED (options mismatch ÔÇö cannot map to user's options)`);
+                                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-MISMATCH] Letter ${aiExtracted.letter} found but IGNORED (options mismatch ├»┬┐┬¢ cannot map to user's options)`);
                             }
                         } catch (e) {
-                            console.warn(`  ­ƒñû [AI-MISMATCH] Extraction failed:`, e?.message || e);
+                            console.warn(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-MISMATCH] Extraction failed:`, e?.message || e);
                         }
                     }
 
@@ -3212,7 +3500,7 @@ export const SearchService = {
                     continue;
                 }
 
-                console.log('  Ô£à Passed all filters ÔÇö entering extraction chain');
+                console.log('  ├»┬┐┬¢S& Passed all filters ├»┬┐┬¢ entering extraction chain');
 
                 // 0) Structured extractors by page signature (PDF-like, AnswerCard, anchored gabarito).
                 const structured = this._extractStructuredEvidenceFromHtml(
@@ -3224,7 +3512,7 @@ export const SearchService = {
                     originalOptions,
                     { parsed: parsedForDiag, type: sourceType, obfuscation, paywall }
                 );
-                console.log(`  ­ƒÅù´©Å Structured extractor: skip=${!!structured?.skip} reason=${structured?.reason || 'none'} letter=${structured?.letter || 'none'} method=${structured?.method || 'none'}`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬©┬Å Structured extractor: skip=${!!structured?.skip} reason=${structured?.reason || 'none'} letter=${structured?.letter || 'none'} method=${structured?.method || 'none'}`);
                 if (structured?.skip) {
                     this._logSourceDiagnostic({
                         phase: 'decision',
@@ -3237,14 +3525,14 @@ export const SearchService = {
                         reason: structured.reason || 'structured-skip'
                     });
                     if (structured.reason === 'obfuscated_html' || structured.reason === 'paywall-overlay') {
-                        console.log(`  Ôøö Structured hard-skip: ${structured.reason}`);
+                        console.log(`  ├»┬┐┬¢: Structured hard-skip: ${structured.reason}`);
                         console.groupEnd();
                         continue;
                     }
-                    console.log(`  ÔÜá´©Å Structured skip (soft): ${structured.reason} ÔÇö continuing to fallbacks`);
+                    console.log(`  ├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å Structured skip (soft): ${structured.reason} ├»┬┐┬¢ continuing to fallbacks`);
                 }
                 if (structured?.letter) {
-                    console.log(`  ­ƒÄ» Structured found letter: ${structured.letter} method=${structured.method} confidence=${structured.confidence} matchQuality=${structured.matchQuality}`);
+                    console.log(`  ├»┬┐┬¢x}├»┬┐┬¢ Structured found letter: ${structured.letter} method=${structured.method} confidence=${structured.confidence} matchQuality=${structured.matchQuality}`);
                     const riskyHost = hostHint === 'passeidireto.com' || hostHint === 'brainly.com.br' || hostHint === 'brainly.com';
                     const structuredMethod = structured.method || 'structured-html';
                     const structuredSim = structured.matchQuality || 0;
@@ -3259,10 +3547,10 @@ export const SearchService = {
                         || structuredCoverage.ratio >= 0.8
                         || structuredCoverage.hits >= Math.min(4, structuredCoverage.total || 4);
                     const isGenericAnchor = structuredMethod === 'generic-anchor';
-                    console.log(`  ­ƒôè Structured coverage: match=${structuredOptionsMatch} strong=${structuredOptionsStrong} hits=${structuredCoverage.hits}/${structuredCoverage.total} ratio=${structuredCoverage.ratio?.toFixed(2)} isGenericAnchor=${isGenericAnchor} riskyHost=${riskyHost} sim=${structuredSim.toFixed(2)}`);
+                    console.log(`  [Structured] coverage: match=${structuredOptionsMatch} strong=${structuredOptionsStrong} hits=${structuredCoverage.hits}/${structuredCoverage.total} ratio=${structuredCoverage.ratio?.toFixed(2)} isGenericAnchor=${isGenericAnchor} riskyHost=${riskyHost} sim=${structuredSim.toFixed(2)}`);
                     // FIX: Extend the risky-host demotion guard to ALL structured
                     // methods (answercard-ql, pdf-anchor-text-match, etc.) when
-                    // option coverage is zero ÔÇö not just generic-anchor.  Without
+                    // option coverage is zero ├»┬┐┬¢ not just generic-anchor.  Without
                     // this, an answercard from a DIFFERENT question on a risky host
                     // gets accepted with high weight despite 0/5 option body matches.
                     const isZeroCoverageOnRiskyHost = riskyHost
@@ -3270,7 +3558,7 @@ export const SearchService = {
                         && structuredCoverage.hits === 0
                         && structuredSim < 0.45;
                     if (isZeroCoverageOnRiskyHost && !isGenericAnchor) {
-                        console.log(`  ÔÜá´©Å Structured ${structuredMethod} demoted: risky host with 0 option hits and low sim=${structuredSim.toFixed(2)}`);
+                        console.log(`  ├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å Structured ${structuredMethod} demoted: risky host with 0 option hits and low sim=${structuredSim.toFixed(2)}`);
                         if (topicSimBase >= 0.2) {
                             collectedForCombined.push({
                                 title,
@@ -3323,14 +3611,14 @@ export const SearchService = {
                             method: structuredMethod,
                             reason: 'generic-anchor-options-mismatch'
                         });
-                        console.log(`  ÔÜá´©Å Generic anchor demoted to combined-only (risky=${riskyHost} strongOpts=${structuredOptionsStrong} sim=${structuredSim.toFixed(2)})`);
+                        console.log(`  ├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å Generic anchor demoted to combined-only (risky=${riskyHost} strongOpts=${structuredOptionsStrong} sim=${structuredSim.toFixed(2)})`);
                         console.groupEnd();
                         continue;
                     }
                     // Remap letter if source has shuffled options
-                    console.log(`  ­ƒöÇ Structured pre-remap letter: ${structured.letter} ÔÇö attempting remap via scopedCombinedText (len=${scopedCombinedText.length})...`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Structured pre-remap letter: ${structured.letter} ├»┬┐┬¢ attempting remap via scopedCombinedText (len=${scopedCombinedText.length})...`);
                     structured.letter = this._remapLetterIfShuffled(structured.letter, scopedCombinedText, originalOptionsMap);
-                    console.log(`  ­ƒöÇ Structured post-remap letter: ${structured.letter}`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Structured post-remap letter: ${structured.letter}`);
                     const baseWeight = getDomainWeight(link);
                     const quality = this.computeMatchQuality(combinedText, questionForInference, originalOptions, originalOptionsMap);
                     const structuredBoost = (structured.confidence || 0.82) >= 0.9 ? 4.4 : 3.7;
@@ -3361,7 +3649,7 @@ export const SearchService = {
                         evidenceBlock
                     });
                     runStats.acceptedForVotes += 1;
-                    console.log(`  Ô£à ACCEPTED via structured: letter=${structured.letter} weight=${weight.toFixed(2)} method=${structuredMethod}`);
+                    console.log(`  ├»┬┐┬¢S& ACCEPTED via structured: letter=${structured.letter} weight=${weight.toFixed(2)} method=${structuredMethod}`);
                     this._logSourceDiagnostic({
                         phase: 'decision',
                         hostHint,
@@ -3374,7 +3662,12 @@ export const SearchService = {
                         letter: structured.letter
                     });
                     const { bestLetter, votes } = this._computeVotesAndState(sources);
-                    if (bestLetter && (votes[bestLetter] || 0) >= 6.5) { console.log(`  ­ƒÅü Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
+                    if (shouldEarlyExit(bestLetter, votes)) {
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ Early exit: votes[${bestLetter}]=${votes[bestLetter]}`);
+                        earlyExitTriggered = true;
+                        console.groupEnd();
+                        break;
+                    }
                     console.groupEnd();
                     continue;
                 }
@@ -3383,9 +3676,9 @@ export const SearchService = {
                 let extracted = null;
                 if (hostHint === 'passeidireto.com' || hostHint === 'studocu.com') {
                     const blockedByIntegrity = !!obfuscation?.isObfuscated || !!paywall?.isPaywalled || (hasOptions && !optionsMatchBase && !allowStructuredMismatchBypass);
-                    console.log(`  ­ƒôä PDF-highlight check: blockedByIntegrity=${blockedByIntegrity} (obf=${!!obfuscation?.isObfuscated} pw=${!!paywall?.isPaywalled} optMismatch=${hasOptions && !optionsMatchBase})`);
+                    console.log(`  ├»┬┐┬¢x PDF-highlight check: blockedByIntegrity=${blockedByIntegrity} (obf=${!!obfuscation?.isObfuscated} pw=${!!paywall?.isPaywalled} optMismatch=${hasOptions && !optionsMatchBase})`);
                     if (blockedByIntegrity) {
-                        console.log(`  Ôøö PDF-highlight blocked: integrity check failed`);
+                        console.log(`  ├»┬┐┬¢: PDF-highlight blocked: integrity check failed`);
                         this._logSourceDiagnostic({
                             phase: 'decision',
                             hostHint,
@@ -3401,9 +3694,9 @@ export const SearchService = {
                         continue;
                     }
                     extracted = this._extractPdfLikeHighlightLetterFromHtml(snap?.html || '', questionStem, originalOptionsMap, originalOptions);
-                    console.log(`  ­ƒôä PDF-highlight result: letter=${extracted?.letter || 'none'} method=${extracted?.method || 'none'} confidence=${extracted?.confidence || 0} evidence="${extracted?.evidence || 'none'}"`);
+                    console.log(`  ├»┬┐┬¢x PDF-highlight result: letter=${extracted?.letter || 'none'} method=${extracted?.method || 'none'} confidence=${extracted?.confidence || 0} evidence="${extracted?.evidence || 'none'}"`);
                     if (extracted?.letter) {
-                        console.log(`  ­ƒôä PDF-highlight raw letter: ${extracted.letter} ÔÇö attempting remap via scopedCombinedText (len=${scopedCombinedText.length})...`);
+                        console.log(`  ├»┬┐┬¢x PDF-highlight raw letter: ${extracted.letter} ├»┬┐┬¢ attempting remap via scopedCombinedText (len=${scopedCombinedText.length})...`);
                         // Remap letter if source has shuffled options
                         extracted.letter = this._remapLetterIfShuffled(extracted.letter, scopedCombinedText, originalOptionsMap);
                         console.log(`SearchService: PDF signal detected. host=${hostHint} letter=${extracted.letter} method=${extracted.method || 'ff1-highlight'}`);
@@ -3414,7 +3707,7 @@ export const SearchService = {
                         const signalBoost = heuristicSignal ? 1.8 : 3.2;
                         const confFactor = Math.max(0.35, Math.min(1.0, Number(extracted.confidence) || 0.82));
                         const adjustedSignalBoost = signalBoost * confFactor;
-                        console.log(`  ­ƒôä PDF weight factors: base=${baseWeight.toFixed(2)} signal=${signalBoost.toFixed(2)} conf=${confFactor.toFixed(2)} adjustedSignal=${adjustedSignalBoost.toFixed(2)} quality=${quality}`);
+                        console.log(`  ├»┬┐┬¢x PDF weight factors: base=${baseWeight.toFixed(2)} signal=${signalBoost.toFixed(2)} conf=${confFactor.toFixed(2)} adjustedSignal=${adjustedSignalBoost.toFixed(2)} quality=${quality}`);
                         const weight = baseWeight + adjustedSignalBoost + (quality * 0.25);
                         const hostPrefix = hostHint === 'passeidireto.com' ? 'passeidireto' : 'studocu';
                         const sourceId = `${hostHint || 'source'}:${sources.length + 1}`;
@@ -3453,7 +3746,7 @@ export const SearchService = {
                             letter: extracted.letter
                         });
                         const { bestLetter, votes } = this._computeVotesAndState(sources);
-                        if (bestLetter && (votes[bestLetter] || 0) >= 6.5) { console.log(`  ­ƒÅü Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
+                        if (shouldEarlyExit(bestLetter, votes)) { console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
                         console.groupEnd();
                         continue;
                     }
@@ -3479,25 +3772,25 @@ export const SearchService = {
 
                 // 2) Enhanced local extraction (uses _findQuestionBlock + _extractExplicitGabarito)
                 const localResult = this._extractAnswerLocally(combinedText, questionForInference, originalOptions);
-                console.log(`  ­ƒôØ Local extraction: letter=${localResult?.letter || 'none'} type=${localResult?.evidenceType || 'none'} confidence=${localResult?.confidence || 0}`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Local extraction: letter=${localResult?.letter || 'none'} type=${localResult?.evidenceType || 'none'} confidence=${localResult?.confidence || 0}`);
                 // TopicSim gate: gabarito from low-similarity sources (compilados with many questions)
-                // is extremely unreliable ÔÇö the matched pattern is likely for a DIFFERENT question.
+                // is extremely unreliable ├»┬┐┬¢ the matched pattern is likely for a DIFFERENT question.
                 if (localResult?.letter && topicSimBase < 0.50) {
-                    console.log(`  Ôøö Gabarito REJECTED: topicSim=${topicSimBase.toFixed(3)} < 0.50 ÔÇö likely wrong question in compilado`);
+                    console.log(`  ├»┬┐┬¢: Gabarito REJECTED: topicSim=${topicSimBase.toFixed(3)} < 0.50 ├»┬┐┬¢ likely wrong question in compilado`);
                     localResult.letter = null;
                 }
                 if (localResult?.letter) {
-                    console.log(`  ­ƒöÇ Local pre-remap letter: ${localResult.letter}`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Local pre-remap letter: ${localResult.letter}`);
                     // Remap letter if source has shuffled options
                     localResult.letter = this._remapLetterIfShuffled(localResult.letter, scopedCombinedText, originalOptionsMap);
-                    console.log(`  ­ƒöÇ Local post-remap letter: ${localResult.letter}`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Local post-remap letter: ${localResult.letter}`);
                     const baseWeight = getDomainWeight(link);
                     const quality = this.computeMatchQuality(combinedText, questionForInference, originalOptions, originalOptionsMap);
                     let weight = baseWeight + 2.6 + (quality * 0.4);
-                    // Reduce gabarito weight when topicSim is moderate ÔÇö source may be wrong question
+                    // Reduce gabarito weight when topicSim is moderate ├»┬┐┬¢ source may be wrong question
                     if (topicSimBase < 0.70) {
                         weight *= topicSimBase;
-                        console.log(`  ÔÜá´©Å Gabarito weight reduced: topicSim=${topicSimBase.toFixed(3)} ÔåÆ weight=${weight.toFixed(2)}`);
+                        console.log(`  ├»┬┐┬¢a├»┬┐┬¢├»┬©┬Å Gabarito weight reduced: topicSim=${topicSimBase.toFixed(3)} ├»┬┐┬¢  weight=${weight.toFixed(2)}`);
                     }
                     const sourceId = `${hostHint || 'source'}:${sources.length + 1}`;
                     const evidenceBlock = this._buildEvidenceBlock({
@@ -3536,19 +3829,24 @@ export const SearchService = {
                         letter: localResult.letter
                     });
                     const { bestLetter, votes } = this._computeVotesAndState(sources);
-                    if (bestLetter && (votes[bestLetter] || 0) >= 6.5) { console.log(`  ­ƒÅü Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
+                    if (shouldEarlyExit(bestLetter, votes)) {
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ Early exit: votes[${bestLetter}]=${votes[bestLetter]}`);
+                        earlyExitTriggered = true;
+                        console.groupEnd();
+                        break;
+                    }
                     console.groupEnd();
                     continue;
                 }
 
                 // 3) Fallback: simpler explicit letter extraction
                 extracted = this._extractExplicitLetterFromText(combinedText, questionStem, originalOptions);
-                console.log(`  ­ƒöñ Explicit letter: letter=${extracted?.letter || 'none'} confidence=${extracted?.confidence || 0}`);
+                console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Explicit letter: letter=${extracted?.letter || 'none'} confidence=${extracted?.confidence || 0}`);
                 if (extracted?.letter) {
-                    console.log(`  ­ƒöÇ Explicit pre-remap letter: ${extracted.letter}`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Explicit pre-remap letter: ${extracted.letter}`);
                     // Remap letter if source has shuffled options
                     extracted.letter = this._remapLetterIfShuffled(extracted.letter, scopedCombinedText, originalOptionsMap);
-                    console.log(`  ­ƒöÇ Explicit post-remap letter: ${extracted.letter}`);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ Explicit post-remap letter: ${extracted.letter}`);
                     const baseWeight = getDomainWeight(link);
                     const weight = baseWeight + 2.0;
                     const sourceId = `${hostHint || 'source'}:${sources.length + 1}`;
@@ -3586,17 +3884,22 @@ export const SearchService = {
                         letter: extracted.letter
                     });
                     const { bestLetter, votes } = this._computeVotesAndState(sources);
-                    if (bestLetter && (votes[bestLetter] || 0) >= 6.5) { console.log(`  ­ƒÅü Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
+                    if (shouldEarlyExit(bestLetter, votes)) {
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ Early exit: votes[${bestLetter}]=${votes[bestLetter]}`);
+                        runStats.earlyExitTriggered = true;
+                        console.groupEnd();
+                        break;
+                    }
                     console.groupEnd();
                     continue;
                 }
 
                 // 3.5) AI per-page deep extraction: when regex/DOM extractors all failed,
-                // send the page text to AI for a "pente fino" ÔÇö finds answers that patterns miss.
+                // send the page text to AI for a "pente fino" ├»┬┐┬¢ finds answers that patterns miss.
                 // Truncating to 3500 chars drastically cuts prompt tokens while maintaining context.
                 if (aiExtractionCount < 1 && topicSimBase >= 0.35 && !obfuscation?.isObfuscated && scopedCombinedText.length >= 250) {
-                    const aiScopedText = this._buildQuestionScopedText(combinedText, questionForInference, 3500);
-                    console.log(`  ­ƒñû [AI-EXTRACT] Attempting AI page extraction (call ${aiExtractionCount + 1}/1, topicSim=${topicSimBase.toFixed(3)}, textLen=${aiScopedText.length}, host=${hostHint})`);
+                    const aiScopedText = this._buildQuestionScopedText(combinedText, questionForInference, 3500, originalOptions);
+                    console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Attempting AI page extraction (call ${aiExtractionCount + 1}/1, topicSim=${topicSimBase.toFixed(3)}, textLen=${aiScopedText.length}, host=${hostHint})`);
                     if (typeof onStatus === 'function') {
                         onStatus(`AI analyzing ${hostHint || 'source'} (${runStats.analyzed}/${topResults.length})...`);
                     }
@@ -3612,11 +3915,11 @@ export const SearchService = {
                             link,
                             title
                         });
-                        console.log(`  ­ƒñû [AI-EXTRACT] Knowledge collected from ${hostHint} (${aiExtracted.knowledge.length} chars, pool size=${aiKnowledgePool.length})`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Knowledge collected from ${hostHint} (${aiExtracted.knowledge.length} chars, pool size=${aiKnowledgePool.length})`);
                     }
 
                     // Cross-question guard: verify the AI's evidence actually relates to
-                    // the user's question ÔÇö multi-question pages often cause the AI to
+                    // the user's question ├»┬┐┬¢ multi-question pages often cause the AI to
                     // find a gabarito from a DIFFERENT question on the same page.
                     if (aiExtracted?.letter && aiExtracted?.evidence && originalOptionsMap) {
                         const evNorm = this._normalizeOption(aiExtracted.evidence);
@@ -3629,10 +3932,10 @@ export const SearchService = {
                         const stemTokens = this._extractKeyTokens(questionStem);
                         const stemHits = stemTokens.filter(t => evNorm.includes(t)).length;
                         const stemRatio = stemTokens.length > 0 ? stemHits / stemTokens.length : 1;
-                        console.log(`  ­ƒñû [AI-EXTRACT] Cross-Q check: claimedHits=${claimedHits}/${claimedTokens.length} (${claimedRatio.toFixed(2)}) stemHits=${stemHits}/${stemTokens.length} (${stemRatio.toFixed(2)})`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Cross-Q check: claimedHits=${claimedHits}/${claimedTokens.length} (${claimedRatio.toFixed(2)}) stemHits=${stemHits}/${stemTokens.length} (${stemRatio.toFixed(2)})`);
                         if (claimedRatio < 0.25 && stemRatio < 0.4) {
-                            console.log(`  ­ƒñû [AI-EXTRACT] ÔØî Cross-question REJECTED: evidence relates to a different question on the page`);
-                            console.log(`  ­ƒñû [AI-EXTRACT] Keeping knowledge but discarding letter ${aiExtracted.letter}`);
+                            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] ├»┬┐┬¢R Cross-question REJECTED: evidence relates to a different question on the page`);
+                            console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Keeping knowledge but discarding letter ${aiExtracted.letter}`);
                             aiExtracted.letter = null;
                             // Strip misleading letter/resultado from knowledge so it
                             // doesn't poison downstream reflection
@@ -3646,9 +3949,9 @@ export const SearchService = {
                     }
 
                     if (aiExtracted?.letter) {
-                        console.log(`  ­ƒñû [AI-EXTRACT] Letter found: ${aiExtracted.letter} (pre-remap)`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Letter found: ${aiExtracted.letter} (pre-remap)`);
                         aiExtracted.letter = this._remapLetterIfShuffled(aiExtracted.letter, scopedCombinedText, originalOptionsMap);
-                        console.log(`  ­ƒñû [AI-EXTRACT] Post-remap letter: ${aiExtracted.letter}`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] Post-remap letter: ${aiExtracted.letter}`);
                         const baseWeight = getDomainWeight(link);
                         const quality = this.computeMatchQuality(combinedText, questionForInference, originalOptions, originalOptionsMap);
                         const weight = baseWeight + 2.2 + (quality * 0.35);
@@ -3688,18 +3991,18 @@ export const SearchService = {
                             method: 'ai-page-extraction',
                             letter: aiExtracted.letter
                         });
-                        console.log(`  Ô£à ACCEPTED via AI page extraction: letter=${aiExtracted.letter} weight=${weight.toFixed(2)}`);
+                        console.log(`  ├»┬┐┬¢S& ACCEPTED via AI page extraction: letter=${aiExtracted.letter} weight=${weight.toFixed(2)}`);
                         const { bestLetter, votes } = this._computeVotesAndState(sources);
-                        if (bestLetter && (votes[bestLetter] || 0) >= 6.5) { console.log(`  ­ƒÅü Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
+                        if (shouldEarlyExit(bestLetter, votes)) { console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ Early exit: votes[${bestLetter}]=${votes[bestLetter]}`); console.groupEnd(); break; }
                         console.groupEnd();
                         continue;
                     } else {
-                        console.log(`  ­ƒñû [AI-EXTRACT] No letter found for ${hostHint} ÔÇö knowledge ${aiExtracted?.knowledge ? 'saved' : 'empty'}`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢ [AI-EXTRACT] No letter found for ${hostHint} ├»┬┐┬¢ knowledge ${aiExtracted?.knowledge ? 'saved' : 'empty'}`);
                     }
                 }
 
                 // 4) No explicit evidence found: keep as low-priority AI evidence.
-                console.log(`  Ôä╣´©Å No direct evidence found ÔÇö collecting for AI combined`);
+                console.log(`  ├»┬┐┬¢├»┬┐┬¢├»┬©┬Å No direct evidence found ├»┬┐┬¢ collecting for AI combined`);
                 const clipped = scopedCombinedText.slice(0, 4000);
                 if (clipped.length >= 200) {
                     const topicSim = topicSimBase;
@@ -3735,12 +4038,12 @@ export const SearchService = {
 
         // Merge aiEvidence + collectedForCombined, sorted by topic similarity
 
-        // ÔòÉÔòÉÔòÉ SNIPPET-LEVEL GABARITO EXTRACTION ÔòÉÔòÉÔòÉ
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ SNIPPET-LEVEL GABARITO EXTRACTION ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
         // When no direct sources found, try to extract explicit gabarito from Serper
         // snippet + title text for each result. This catches cases where the SERP itself
         // reveals the answer (e.g. "Gabarito: E" in snippet) without needing page fetch.
         if (sources.length === 0 && hasOptions) {
-            console.group('­ƒôï Snippet-level gabarito extraction');
+            console.group('├»┬┐┬¢x9 Snippet-level gabarito extraction');
             for (const result of topResults) {
                 const snipText = `${result.title || ''}. ${result.snippet || ''}`.trim();
                 if (snipText.length < 60) continue;
@@ -3781,7 +4084,7 @@ export const SearchService = {
                         evidenceBlock
                     });
                     runStats.acceptedForVotes += 1;
-                    console.log(`  Ô£à Snippet gabarito: letter=${letter} host=${hostHint} sim=${snipSim.toFixed(2)} coverage=${snipCoverage.hits}/${snipCoverage.total} weight=${weight.toFixed(2)}`);
+                    console.log(`  ├»┬┐┬¢S& Snippet gabarito: letter=${letter} host=${hostHint} sim=${snipSim.toFixed(2)} coverage=${snipCoverage.hits}/${snipCoverage.total} weight=${weight.toFixed(2)}`);
                 }
             }
             console.log(`  Snippet gabarito sources added: ${sources.filter(s => s.evidenceType === 'snippet-gabarito').length}`);
@@ -3830,14 +4133,14 @@ export const SearchService = {
             ...snippetEvidence.map(e => ({ ...e, origin: 'snippet' }))
         ].sort((a, b) => (b.topicSim || 0) - (a.topicSim || 0));
 
-        // ÔòÉÔòÉÔòÉ DEBUG: AI Combined Pool ÔòÉÔòÉÔòÉ
-        console.group('­ƒºá AI Combined Evidence Pool');
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ DEBUG: AI Combined Pool ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+        console.group('├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ AI Combined Evidence Pool');
         console.log(`Direct sources found: ${sources.length}`);
         console.log(`AI evidence pool: ${aiEvidence.length} | Mismatch pool: ${collectedForCombined.length} | Snippet pool: ${snippetEvidence.length}`);
         console.log(`AI knowledge pool: ${aiKnowledgePool.length} entries`);
         if (aiKnowledgePool.length > 0) {
             aiKnowledgePool.forEach((k, i) => {
-                console.log(`  ­ƒôÜ [${i}] host=${k.host} topicSim=${(k.topicSim || 0).toFixed(3)} knowledge=${(k.knowledge || '').length} chars origin=${k.origin || 'direct'}`);
+                console.log(`  ├»┬┐┬¢xa [${i}] host=${k.host} topicSim=${(k.topicSim || 0).toFixed(3)} knowledge=${(k.knowledge || '').length} chars origin=${k.origin || 'direct'}`);
             });
         }
         console.log(`Total for combined: ${allForCombined.length}`);
@@ -3861,7 +4164,7 @@ export const SearchService = {
                 .filter((e) => {
                     const topicSim = e.topicSim || 0;
                     if (topicSim < minTopicSim) {
-                        console.log(`    ÔØî Filtered (low topicSim ${topicSim.toFixed(3)} < ${minTopicSim}): ${e.hostHint}`);
+                        console.log(`    ├»┬┐┬¢R Filtered (low topicSim ${topicSim.toFixed(3)} < ${minTopicSim}): ${e.hostHint}`);
                         return false;
                     }
                     if (!hasOptions) return true;
@@ -3877,7 +4180,7 @@ export const SearchService = {
                     // DOES contain the user's question. Only reject when coverage is weak.
                     if (origin === 'aievidence' && riskyCombinedHosts.has(host)) {
                         if (!strongCoverage) {
-                            console.log(`    ÔØî Risky aiEvidence rejected (weak coverage): host=${host} topicSim=${topicSim.toFixed(2)} coverage=${coverage.hits}/${coverage.total}`);
+                            console.log(`    ├»┬┐┬¢R Risky aiEvidence rejected (weak coverage): host=${host} topicSim=${topicSim.toFixed(2)} coverage=${coverage.hits}/${coverage.total}`);
                             return false;
                         }
                     }
@@ -3886,7 +4189,7 @@ export const SearchService = {
                         if (!strongCoverage) return false;
                         if (topicSim < 0.30) return false;
                         // Allow risky-host snippets when they have strong option coverage
-                        // (snippets are just title + SERP text ÔÇö no cross-question risk).
+                        // (snippets are just title + SERP text ├»┬┐┬¢ no cross-question risk).
                     }
 
                     if (strongCoverage) return true;
@@ -3907,11 +4210,11 @@ export const SearchService = {
                         && !e.paywalled
                         && isTrustedCombinedHost(host)
                     ) {
-                        console.log(`    Ô£à Cross-question evidence ADMITTED: host=${host} topicSim=${topicSim.toFixed(2)} textLen=${(e.text || '').length}`);
+                        console.log(`    ├»┬┐┬¢S& Cross-question evidence ADMITTED: host=${host} topicSim=${topicSim.toFixed(2)} textLen=${(e.text || '').length}`);
                         console.log(`SearchService: Cross-question evidence admitted for AI combined: host=${host} topicSim=${topicSim.toFixed(2)} textLen=${(e.text || '').length}`);
                         return true;
                     } else if (origin === 'mismatch') {
-                        console.log(`    ÔØî Cross-question REJECTED: host=${host} topicSim=${topicSim.toFixed(2)} len=${(e.text || '').length}`);
+                        console.log(`    ├»┬┐┬¢R Cross-question REJECTED: host=${host} topicSim=${topicSim.toFixed(2)} len=${(e.text || '').length}`);
                     }
 
                     if (riskyCombinedHosts.has(host) || e.obfuscated || e.paywalled) return false;
@@ -3939,8 +4242,8 @@ export const SearchService = {
             });
             const minRelevantSources = hasOptions && !hasStrongExplicit ? 2 : 1;
 
-            // ÔòÉÔòÉÔòÉ DEBUG: AI Combined Decision ÔòÉÔòÉÔòÉ
-            console.group('­ƒñû AI Combined Decision');
+            // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ DEBUG: AI Combined Decision ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+            console.group('├»┬┐┬¢x├»┬┐┬¢ AI Combined Decision');
             console.log(`Relevant sources after filtering: ${relevant.length}`);
             relevant.forEach((e, i) => {
                 console.log(`  [${i}] origin=${e.origin} host=${e.hostHint} topicSim=${(e.topicSim || 0).toFixed(3)} optMatch=${e.optionsMatch} textLen=${(e.text || '').length}`);
@@ -3948,7 +4251,7 @@ export const SearchService = {
             console.log(`desperateMode=false | hasStrongExplicit=${hasStrongExplicit} | hasReliableOptionAligned=${hasReliableOptionAlignedSource} | minRelevantSources=${minRelevantSources}`);
 
             if (hasOptions && (!hasReliableOptionAlignedSource || relevant.length < minRelevantSources)) {
-                console.log(`Ôøö AI combined SKIPPED: weak option alignment (relevant=${relevant.length}, reliable=${hasReliableOptionAlignedSource})`);
+                console.log(`├»┬┐┬¢: AI combined SKIPPED: weak option alignment (relevant=${relevant.length}, reliable=${hasReliableOptionAlignedSource})`);
                 console.log(`SearchService: AI combined skipped - weak option alignment (relevant=${relevant.length}, reliable=${hasReliableOptionAlignedSource})`);
             }
             const strongRelevant = relevant.filter((e) => {
@@ -4012,11 +4315,11 @@ export const SearchService = {
 
             console.log(`canProceedAI=${canProceedAI}`);
             if (canProceedAISynthesisOnly) {
-                console.log(`Ô£à AI synthesis-only mode enabled: strongRelevant=${strongRelevant.length}, domainDiversity=${strongRelevantDomainCount}`);
+                console.log(`├»┬┐┬¢S& AI synthesis-only mode enabled: strongRelevant=${strongRelevant.length}, domainDiversity=${strongRelevantDomainCount}`);
                 console.log(`   anchorMode=${hasEliteAnchoredEvidence} corroboratingSnippets=${corroboratingSnippetCount}`);
             }
             if (!canProceedAI) {
-                console.log('ÔØî AI combined will NOT run');
+                console.log('├»┬┐┬¢R AI combined will NOT run');
                 console.groupEnd();
             }
 
@@ -4067,7 +4370,7 @@ export const SearchService = {
                             const supportMargin = topOption && secondOption ? (topOption.score - secondOption.score) : 1;
                             // Dynamic margin: when the selected option has decent support (score > 0.4),
                             // allow a wider margin because lexical overlap doesn't capture semantics
-                            // (e.g. "Exige" vs "N├úo exige" share most tokens but are opposites).
+                            // (e.g. "Exige" vs "N├â┬úo exige" share most tokens but are opposites).
                             const effectiveMarginThreshold = (selected && selected.score >= 0.40)
                                 ? 0.25
                                 : (selected && selected.score >= 0.30 ? 0.12 : 0.03);
@@ -4079,7 +4382,7 @@ export const SearchService = {
                             console.log(`SearchService: AI synthesis support check => selected=${selected?.letter || 'none'} score=${(selected?.score || 0).toFixed(3)} tokenRatio=${(selected?.tokenRatio || 0).toFixed(3)} top=${topOption?.letter || 'none'} topScore=${(topOption?.score || 0).toFixed(3)} margin=${supportMargin.toFixed(3)}`);
 
                             if (!selectedSupported) {
-                                console.log(`Ôøö AI combined letter rejected by evidence-support guard (selected=${aiLetter}, top=${topOption?.letter || 'none'})`);
+                                console.log(`├»┬┐┬¢: AI combined letter rejected by evidence-support guard (selected=${aiLetter}, top=${topOption?.letter || 'none'})`);
                                 aiLetter = null;
                             }
                         }
@@ -4087,7 +4390,7 @@ export const SearchService = {
                     if (aiLetter) {
                         // Weight depends on whether we already have explicit evidence.
                         // When ALL sources are cross-question (different questions, no option match),
-                        // reduce weight significantly ÔÇö cross-question evidence is inherently unreliable.
+                        // reduce weight significantly ├»┬┐┬¢ cross-question evidence is inherently unreliable.
                         const allCrossQuestion = relevant.every(e => String(e.origin || '') === 'mismatch' || e.optionsMatch === false);
                         const aiWeight = hasStrongExplicit
                             ? 0.3
@@ -4158,7 +4461,7 @@ export const SearchService = {
                             runStats.acceptedForVotes += 1;
                             console.log(`SearchService: AI knowledge => Letra ${knLetter}, weight=${knWeight}`);
                             if (aiLetter && knLetter !== aiLetter) {
-                                console.warn(`SearchService: CONFLICT evidence=${aiLetter} vs knowledge=${knLetter} ÔÇö knowledge (${knWeight}) overrides evidence (${aiWeightUsed ?? 'n/a'})`);
+                                console.warn(`SearchService: CONFLICT evidence=${aiLetter} vs knowledge=${knLetter} ├»┬┐┬¢ knowledge (${knWeight}) overrides evidence (${aiWeightUsed ?? 'n/a'})`);
                             }
                         }
                     }
@@ -4171,7 +4474,7 @@ export const SearchService = {
             }
         }
 
-        // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É PAGE-LEVEL GABARITO TIE-BREAKER ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+        // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É PAGE-LEVEL GABARITO TIE-BREAKER ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
         if (pageGabarito) {
             const pgLetter = (pageGabarito || '').toUpperCase().trim();
             if (/^[A-E]$/.test(pgLetter)) {
@@ -4200,11 +4503,11 @@ export const SearchService = {
             }
         }
 
-        // ÔòÉÔòÉÔòÉ AI COMBINED REFLECTION FALLBACK ÔòÉÔòÉÔòÉ
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ AI COMBINED REFLECTION FALLBACK ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
         // When no sources were accepted for voting but we accumulated knowledge
         // from AI page extraction, try a combined reflection as last resort.
         if (sources.length === 0 && aiKnowledgePool.length > 0 && hasOptions) {
-            console.group('­ƒºá AI Combined Reflection Fallback');
+            console.group('├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ AI Combined Reflection Fallback');
             console.log(`No voting sources. Knowledge pool has ${aiKnowledgePool.length} entries from AI extraction.`);
             aiKnowledgePool.forEach((k, i) => {
                 console.log(`  [${i}] host=${k.host} topicSim=${(k.topicSim || 0).toFixed(3)} knowledge=${(k.knowledge || '').length} chars origin=${k.origin || 'direct'}`);
@@ -4222,7 +4525,7 @@ export const SearchService = {
                     if (/^[A-E]$/.test(reflectLetter)) {
                         // Remap if options were shuffled
                         reflectLetter = this._remapLetterIfShuffled(reflectLetter, '', originalOptionsMap);
-                        console.log(`  ­ƒºá [REFLECTION] Letter found: ${reflectLetter}`);
+                        console.log(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ [REFLECTION] Letter found: ${reflectLetter}`);
 
                         const reflectWeight = 1.2; // Lower than direct evidence but higher than zero
                         const sourceId = `ai-reflection:${sources.length + 1}`;
@@ -4249,19 +4552,19 @@ export const SearchService = {
                             evidenceBlock
                         });
                         runStats.acceptedForVotes += 1;
-                        console.log(`  Ô£à AI reflection accepted: letter=${reflectLetter} weight=${reflectWeight}`);
+                        console.log(`  ├»┬┐┬¢S& AI reflection accepted: letter=${reflectLetter} weight=${reflectWeight}`);
                     } else {
-                        console.log(`  ÔØî AI reflection returned invalid letter: "${reflectionResult.letter}"`);
+                        console.log(`  ├»┬┐┬¢R AI reflection returned invalid letter: "${reflectionResult.letter}"`);
                     }
                 } else {
-                    console.log(`  ÔØî AI reflection returned no letter (INCONCLUSIVO)`);
+                    console.log(`  ├»┬┐┬¢R AI reflection returned no letter (INCONCLUSIVO)`);
                 }
             } catch (e) {
-                console.warn(`  ­ƒºá AI reflection error:`, e?.message || e);
+                console.warn(`  ├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ AI reflection error:`, e?.message || e);
             }
             console.groupEnd();
         } else if (sources.length === 0 && aiKnowledgePool.length === 0) {
-            console.log('­ƒºá No knowledge pool accumulated ÔÇö reflection fallback skipped');
+            console.log('├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢ No knowledge pool accumulated ├»┬┐┬¢ reflection fallback skipped');
         }
 
         if (sources.length === 0) {
@@ -4280,8 +4583,8 @@ export const SearchService = {
             evidenceConsensus
         } = this._computeVotesAndState(sources);
 
-        // ÔòÉÔòÉÔòÉ DEBUG: Final Voting Breakdown ÔòÉÔòÉÔòÉ
-        console.group('­ƒÅ│´©Å Final Voting Breakdown');
+        // ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢ DEBUG: Final Voting Breakdown ├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢├»┬┐┬¢"├»┬┐┬¢
+        console.group('├»┬┐┬¢x├»┬┐┬¢├»┬┐┬¢├»┬©┬Å Final Voting Breakdown');
         console.log('All sources:');
         sources.forEach((s, i) => {
             console.log(`  [${i}] host=${s.hostHint} letter=${s.letter} weight=${s.weight?.toFixed?.(2) || s.weight} type=${s.evidenceType} method=${s.extractionMethod || 'n/a'}`);
@@ -4302,7 +4605,12 @@ export const SearchService = {
             ? `Letra ${bestLetter}: ${answerText}`.trim()
             : (sources[0]?.answer || '').trim();
 
-        // ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É Determine evidence tier ├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É├â┬ó├óÔé¼┬ó├é┬É
+        console.log(`  ├»┬┐┬¢x}├»┬┐┬¢ [FINAL DECISION]: ${answer}`);
+        if (bestLetter) {
+            console.log(`    Consensus: ${votes[bestLetter]} votes out of ${runStats.acceptedForVotes} accepted sources.`);
+        }
+
+        // ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É Determine evidence tier ├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É├âÔÇÖ├é┬ó├â┬ó├»┬┐┬¢├»┬┐┬¢├é┬ó├»┬┐┬¢├é┬É
         const isAiOnly = sources.every(s => s.evidenceType === 'ai' || s.evidenceType === 'ai-combined');
         const hasExplicitEvidence = sources.some(s => s.evidenceType && s.evidenceType !== 'ai' && s.evidenceType !== 'ai-combined');
         let evidenceTier = 'EVIDENCE_WEAK';
@@ -4384,9 +4692,9 @@ export const SearchService = {
         const questionFingerprint = await this._canonicalHash(questionForInference);
         const buildInconclusiveNoEvidence = (reason) => [{
             question: questionText,
-            answer: 'INCONCLUSIVO: sem evid├¬ncia externa confi├ível para marcar alternativa.',
+            answer: 'INCONCLUSIVO: sem evid├â┬¬ncia externa confi├â┬ível para marcar alternativa.',
             answerLetter: null,
-            answerText: 'Sem evid├¬ncia externa confi├ível para marcar alternativa.',
+            answerText: 'Sem evid├â┬¬ncia externa confi├â┬ível para marcar alternativa.',
             aiFallback: false,
             evidenceTier: 'EVIDENCE_WEAK',
             resultState: 'inconclusive',
